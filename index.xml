<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on engineering math</title>
    <link>/</link>
    <description>Recent content on Notes on engineering math</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Dec 2020 00:00:00 +0530</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algo walkthrough: product of array except self</title>
      <link>/posts/20201212172313-algo_walkthrough_product_of_array_except_self/</link>
      <pubDate>Sat, 12 Dec 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20201212172313-algo_walkthrough_product_of_array_except_self/</guid>
      <description>Link to the problem.
What not to do Let&amp;rsquo;s ignore the note for now.
Using division If we use division, how would we solve this problem? We could start with a single pass over the array. In this pass, we multiply all the elements and calculate complete_product. For each element e, we can now calculate \(\frac{complete-product}{e}\). This, stored in an array, is our final result.
More than O(n) What if we had no time constraints?</description>
    </item>
    
    <item>
      <title>Algo walkthrough: spiral matrix</title>
      <link>/posts/20201205201509-algo_walkthrough_spiral_matrix/</link>
      <pubDate>Sun, 06 Dec 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20201205201509-algo_walkthrough_spiral_matrix/</guid>
      <description>Link to the problem.
Intuitions Track the spiral literally I can definitely think of at least one solution involving 4 pointers . The 4 pointers track the size of the matrix as the spiral closes inwards.
  But how to track the current location? A tuple with row and column numbers? At first we set direction to move towards right. When the column number reaches a value equal to right we change direction to move downwards.</description>
    </item>
    
    <item>
      <title>Algo walkthrough: number of ways to decode message</title>
      <link>/posts/20201205103553-algo_walkthrough_number_of_ways_to_decode_message/</link>
      <pubDate>Sat, 05 Dec 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20201205103553-algo_walkthrough_number_of_ways_to_decode_message/</guid>
      <description>Link to the problem
Intuitions Variable code length The root of the issue is variable code length. Some codes are length-1 (a-i), some are length-2 (j-z). This leads to may lead to; there are conditions to deal with but we&amp;#39;ll come to that later  multiple correct decodings for the same input code. Let&amp;rsquo;s take a minimal example of 25 as the input code. We could decode it as be or y.</description>
    </item>
    
    <item>
      <title>Algo walkthrough: set matrix zeroes</title>
      <link>/posts/20201130130544-algo_walkthrough_set_matrix_zeroes/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20201130130544-algo_walkthrough_set_matrix_zeroes/</guid>
      <description>Link to the problem.
Hints  A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution? So this problem is more about space than time.   Intuitions It seems obvious that a single pass through the matrix would work. Is there a reason even a single pass is not needed?</description>
    </item>
    
    <item>
      <title>Algo walkthrough: course schedule</title>
      <link>/posts/20201127172735-algo_walkthrough_course_schedule/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20201127172735-algo_walkthrough_course_schedule/</guid>
      <description>Link to the problem
First impressions It seems every course has pre-requisites. A course c would have the following pre-requisites: [c, p1], [c, p2], .... First we finish all the pre-requisites then we can finish the course c. The pre-requisites will obviously have their own pre-requisites&amp;hellip; and so on. The question says &amp;ldquo;is it possible?&amp;rdquo; which means the inputs may have a situation where this chain of pre-requisites can never be completed because everything depends on everything else i.</description>
    </item>
    
    <item>
      <title>Algo walkthrough: number of islands</title>
      <link>/posts/20201125100541-algo_walkthrough_number_of_islands/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20201125100541-algo_walkthrough_number_of_islands/</guid>
      <description>Link to the problem.
Exploration The first instinct is to lower the dimension of the problem and see what that looks like. A 1D world with stretches of land and water:
                 1 0 0 0 1 1 1 0 0 1    In this case, there are 3 islands. We can count this in a single pass of the array.</description>
    </item>
    
    <item>
      <title>Algo walkthrough: longest sequence in unsorted array</title>
      <link>/posts/20201123210516-algo_walkthrough_longest_sequence_in_unsorted_array/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/20201123210516-algo_walkthrough_longest_sequence_in_unsorted_array/</guid>
      <description>Link to the problem.
Hints  They hint at a \(O(n)\) solution. This can be useful at a later point. They also say the length of the array can be between \(1, 10000\). This means we can a small array of size \(10\) and manually try out solutions. This would probably scale fine. Each element can be huge! \(-10^9, 10^9\). Note that the value is higher than the length of the array.</description>
    </item>
    
    <item>
      <title>Algo walkthrough: swapping elements to find max score</title>
      <link>/posts/20201122105230-algo_walkthrough_swapping_elements_to_find_max_score/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/20201122105230-algo_walkthrough_swapping_elements_to_find_max_score/</guid>
      <description>Initial setup The initial setup consists of an unsorted array. Each element has a score defined as the absolute value of the difference the element&amp;rsquo;s value and its index.
The absolute value The metric for each element gives us a sense of displacement. For example, if an element at index `4` is of value `10` the score for this is `6`. If the element was at index `5` and of value `11`, the score is still `6`.</description>
    </item>
    
    <item>
      <title>Compressed Sensing with the Fourier Ensemble</title>
      <link>/posts/20200611111551-compressed_sensing_with_the_fourier_ensemble/</link>
      <pubDate>Sat, 25 Apr 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20200611111551-compressed_sensing_with_the_fourier_ensemble/</guid>
      <description>I&amp;rsquo;m reading the topic of compressed sensing and I find it extremely dense with a lot of historical perspective. This video is a great start to the topic.
Reproducing the example The example at 14:05 in the video uses a DCT. The cosamp function used below is from this repository. The code here is slightly modified from the jupyter notebook available here.
stx = 0 end = 1 n = 4096 Fs = int( n/(end - stx)) from math import pi from numpy.</description>
    </item>
    
    <item>
      <title>Fourier Analysis</title>
      <link>/posts/20200524030032-pubnotes_ddse_fourier/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20200524030032-pubnotes_ddse_fourier/</guid>
      <description>This is for my notes for Prof. Steve Brunton&amp;rsquo;s video lectures of Fourier Analysis.
Real domain to complex domain The first confusion for me was the shift in the sum limits from real domain to complex domain. The real fourier series is expressed as \(\sum_{k=0}^{\infty} \frac{a_0}{2} + a_k \cos kx + b_k \sin kx\). The intuition here is that harmonics can express any function. The constant term accounts for all the different initial phase shifts of each of these harmonics.</description>
    </item>
    
    <item>
      <title>lassoPlot in python</title>
      <link>/posts/20200624220142-lassoplot_in_python/</link>
      <pubDate>Thu, 26 Mar 2020 00:00:00 +0530</pubDate>
      
      <guid>/posts/20200624220142-lassoplot_in_python/</guid>
      <description>A comparison of python vs matlab
lassoPlot in matlab In matlab, lasso regression&amp;rsquo;s MSE is easily visualized using the command lassoPlot. The following is from Prof. Steve Brunton&amp;rsquo;s uwdatabook page. In the zip file, the exact file is CH03_SEC05_2_LASSO.m. The most relevant parts to create the plot are picked out here:
A = randn(100,10); % Matrix of possible predictors x = [0; 0; 1; 0; 0; 0; -1; 0; 0; 0]; % Two nonzero predictors b = A*x + 2*randn(100,1); % Observations (with noise) xL2 = pinv(A)*b [XL1 FitInfo] = lasso(A,b,&amp;#39;CV&amp;#39;,10); lassoPlot(XL1,FitInfo,&amp;#39;PlotType&amp;#39;,&amp;#39;CV&amp;#39;) save See output below:</description>
    </item>
    
  </channel>
</rss>