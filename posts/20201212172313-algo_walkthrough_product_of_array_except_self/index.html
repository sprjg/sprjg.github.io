<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": ""
    },
    "articleSection" : "posts",
    "name" : "Algo walkthrough: product of array except self",
    "headline" : "Algo walkthrough: product of array except self",
    "description" : "The problem  Given an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\nExample:\nInput: [1,2,3,4] Output: [24,12,8,6]\nNote: Please solve it without division and in O(n).\n Link to the problem.\nWhat not to do Let\u0026rsquo;s ignore the note for now.\nUsing division If we use division, how would we solve this problem?",
    "inLanguage" : "en-US",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2020",
    "datePublished": "2020-12-12 22:25:33 \u002b0530 IST",
    "dateModified" : "2020-12-12 22:25:33 \u002b0530 IST",
    "url" : "\/posts\/20201212172313-algo_walkthrough_product_of_array_except_self\/",
    "wordCount" : "1108",
    "keywords" : [ "Blog" ]
}
</script>


    <title>Algo walkthrough: product of array except self | Notes on engineering math</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
        <link href="https://fonts.googleapis.com/css2?family=Crimson+Text&display=swap" rel="stylesheet">

  </head>

  <body>
    <div class='site-title'> <div> Notes on engineering math </div> </div>
    <div id="posts-list">
    <nav>
    <ul class="menu">
      
      <li><a href="/posts/">Main</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/">About</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>
    </div>

<div class="article-meta">
<a href="/posts" style="text-decoration:none;color:black;"><h1><span class="title">Algo walkthrough: product of array except self</span></h1></a>
</div>

<main>
    <aside class="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#the-problem">The problem</a></li>
    <li><a href="#what-not-to-do">What not to do</a>
      <ul>
        <li><a href="#using-division">Using division</a></li>
        <li><a href="#more-than-o--n">More than O(n)</a></li>
      </ul>
    </li>
    <li><a href="#intuitions">Intuitions</a>
      <ul>
        <li><a href="#on--approx--constant-number-of-passes">\(O(n) \approx\) constant number of passes</a></li>
        <li><a href="#summary-of-approach">Summary of approach</a></li>
      </ul>
    </li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#testing">Testing</a></li>
    <li><a href="#results">Results</a></li>
    <li><a href="#second-try">Second try</a>
      <ul>
        <li><a href="#results">Results</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
    <h2 id="the-problem">The problem</h2>
<blockquote>
<p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Example:</p>
<p>Input:  [1,2,3,4]
Output: [24,12,8,6]</p>
<p>Note: Please solve it without division and in O(n).</p>
</blockquote>
<p><a href="https://leetcode.com/problems/product-of-array-except-self/">Link to the problem.</a></p>
<h2 id="what-not-to-do">What not to do</h2>
<p>Let&rsquo;s ignore the <em>note</em> for now.</p>
<h3 id="using-division">Using division</h3>
<p>If we use division, how would we solve this problem? We could start with a single pass over the array. In this pass, we multiply all the elements and calculate <code>complete_product</code>. For each element <code>e</code>, we can now calculate \(\frac{complete_product}{e}\). This, stored in an array, is our final result.</p>
<h3 id="more-than-o--n">More than O(n)</h3>
<p>What if we had no time constraints? What&rsquo;s our worst brute-force solution?
We could iterate over the array. For each element <code>e</code>, we perform a nested iteration of all the other elements. During this nested iteration, we calculate the product of all the other elements. This is a \(O(n^2)\) solution.</p>
<h2 id="intuitions">Intuitions</h2>
<p>We have a clear idea of the boundaries now: we can do \(O(n)\) but with division or we can do \(O(n^2)\) without division. We are now aiming for a solution that&rsquo;s \(O(n)\) <em>without division</em>.</p>
<h3 id="on--approx--constant-number-of-passes">\(O(n) \approx\) constant number of passes</h3>
<p><span class="sidenote">
<label class="sidenote-label" for="fn-usually-single-pass">Usually</label>

<span class="sidenote-content">There are recurrence relations that lead to overall complexity of \\(\Theta(n)\\) but are not a single pass, but let&#39;s ignore those for now</span>
</span>
 \(O(n)\) implies a constant number of passes over the array. So it seems the <strong>note</strong> is actually a hint.
Let&rsquo;s imagine we start with a single pass over the array. For each element <code>e</code>, we get to perform some constant operations. This could a math operation except division. It&rsquo;s natural to think that the result of this math operation = the result we need for this element = product of the whole array except this element.</p>
<h4 id="result-for-a-single-element">Result for a single element</h4>
<p>Now let&rsquo;s think specifically about a single element&rsquo;s result. What exactly is the product of a whole array except the current element?</p>
<figure>
    <img src="/ox-hugo/screenshot2020-12-12_17-50-36_.png"/> 
</figure>

<p>The current element at index \(i\) is highlighted as yellow. The other elements are grey. We need the product \(p_{i}\) of all these grey elements. Because multiplication is transitive, \(p_i\) is equal to the product of \(p_{\text{left}}, \ p_{\text{right}}\).</p>
<p>\(p_i = p_{\text{left}} \times p_{\text{right}}\)</p>
<h4 id="calculating--p-text-left">Calculating  \(p_{\text{left}}\)</h4>
<p>We are hoping to calculate \(p_{\text{left}}\) for each element using only constant number of operations. Let&rsquo;s denote \(p_{\text{left}}\) for index \(i\) as: \(p^i_{\text{left}}\).
Let&rsquo;s try an inductive line of thinking. The current element is highlighted in yellow:</p>
<figure>
    <img src="/ox-hugo/screenshot2020-12-12_18-05-13_.png"/> 
</figure>

<p>Say we have somehow calculated \(p_{\text{left}}\) for all the elements on the left of current element. So for all indices \(k &lt; i\), we know \(p^k_{\text{left}}\).</p>
<p>Notice that for the yellow element, we only have to multiply the green portion with the grey portion to get \(p^i_{\text{left}}\). We already know the green portion: \(p^{i-1}_{\text{left}}\). We also know the grey element: \(array[i-1]\). This means for the element at \(i\):</p>
<p>\(p^i_{\text{left}} =array[i-1] \times p^{i-1}_{\text{left}}\)</p>
<p>This multiplication is a single operation with two array look-ups leading to a constant time operation.</p>
<h4 id="calculating--p-text-right">Calculating \(p_{\text{right}}\)</h4>
<p>We could approach this similarly except we now start from the rightmost element, \(i=n-1\). We&rsquo;ll have this relation:</p>
<p>\(p^i_{\text{right}} = array[i+1] \times p^{i+1}_{\text{right}}\)</p>
<h4 id="base-cases">Base cases</h4>
<p>Note that \(p^0_{\text{left}} = 1, p^{n-1}_{\text{right}} = 1\). This is to ensure that we can build on top of these using successive multiplication operations. If the operation was an addition we&rsquo;d set them to zero.</p>
<h3 id="summary-of-approach">Summary of approach</h3>
<p>We will calculate \(p_{\text{left}}\) and \(p_{\text{right}}\) for each element. This will take two passes. After this, we&rsquo;ll need one final pass to calculate our result array where we multiple the left and right products for each element. A total of 3 passes.</p>
<h2 id="implementation">Implementation</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">productExceptSelf</span>(nums):
    n <span style="color:#f92672">=</span> len(nums)
    <span style="color:#75715e"># left product</span>
    left <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n
    left[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    left[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">for</span> i, e <span style="color:#f92672">in</span> enumerate(nums[<span style="color:#ae81ff">2</span>:]):
        left[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">*</span> left[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>]

    right <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n
    right[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    right[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
    <span style="color:#66d9ef">for</span> i, e <span style="color:#f92672">in</span> enumerate(nums[<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]):
        right[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> nums[n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span>i] <span style="color:#f92672">*</span> right[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]

    <span style="color:#66d9ef">print</span>(left, right)
    result <span style="color:#f92672">=</span> [left[i] <span style="color:#f92672">*</span> right[n <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, n)]
    <span style="color:#66d9ef">return</span> result
</code></pre></div><h2 id="testing">Testing</h2>
<p>Let&rsquo;s test our implementation with randomly generated arrays:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
n <span style="color:#f92672">=</span> int(random<span style="color:#f92672">.</span>random() <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
array <span style="color:#f92672">=</span> [int(random<span style="color:#f92672">.</span>random() <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, n)]
<span style="color:#66d9ef">print</span>(array)
<span style="color:#66d9ef">print</span>(productExceptSelf(array))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">[0, 1, 2, 8, 0, 6]
[0, 0, 0, 0, 0, 0]
</code></pre></div><h2 id="results">Results</h2>
<p>This implementation scores low against the tests.</p>
<blockquote>
<p>Runtime: 264 ms, faster than 13.34% of Python3 online submissions for Product of Array Except Self.</p>
<p>Memory Usage: 22.5 MB, less than 8.94% of Python3 online submissions for Product of Array Except Self.</p>
</blockquote>
<p>We may have a hint in the problem description:</p>
<blockquote>
<p>Follow up:
Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</p>
</blockquote>
<p>Using two extra arrays counts as \(O(n)\) space. Could we do this without creating intermediate arrays?</p>
<h2 id="second-try">Second try</h2>
<p>The follow up says that a result array does not count as extra space. So we are allowed at most one extra array. What if we used the same approach but changed our memory storage to accommodate this new constraint?
Say we have a single <code>result</code> array. We first calculate and store the left products for each element in this array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">productExceptSelf</span>(nums):
    n <span style="color:#f92672">=</span> len(nums)
    result <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n
    <span style="color:#75715e"># left product</span>
    result[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    result[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">for</span> i, e <span style="color:#f92672">in</span> enumerate(nums[<span style="color:#ae81ff">2</span>:]):
        result[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">*</span> result[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>]
</code></pre></div><p>Now we have a <code>result</code> array with the left products stored. We can now iterate in reverse over this <code>result</code> to do two things at once: calculate the right product and then the final result. This would save us one iteration also. Instead of storing a full <code>right</code> array, we&rsquo;ll just keep track of the last right product which is required for the next computation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    last_right_product <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
        result[i] <span style="color:#f92672">=</span> result[i] <span style="color:#f92672">*</span> last_right_product
        last_right_product <span style="color:#f92672">=</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> last_right_product
    result[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> last_right_product
    <span style="color:#66d9ef">return</span> result
</code></pre></div><h3 id="results">Results</h3>
<p>The results are only marginally better.</p>
<blockquote>
<p>Runtime: 256 ms, faster than 19.75% of Python3 online submissions for Product of Array Except Self.</p>
<p>Memory Usage: 21.8 MB, less than 35.96% of Python3 online submissions for Product of Array Except Self.</p>
</blockquote>
<h4 id="removing-the-enumerate">Removing the <code>enumerate</code></h4>
<p>If we replace the <code>enumerate</code> in the first pass with a counter <code>i</code> and manually increment it, the code runs slightly faster:</p>
<blockquote>
<p>Runtime: 232 ms, faster than 73.80% of Python3 online submissions for Product of Array Except Self.</p>
<p>Memory Usage: 21.8 MB, less than 34.77% of Python3 online submissions for Product of Array Except Self.</p>
</blockquote>

</main>

  <footer>
  <script src="/js/math-code.js"></script>
<script async src="/MathJax/es5/tex-chtml.js"></script>


<script async src="/js/center-img.js"></script>

  
  <hr/>
  © <a href="https://sprjg.github.io">SPR</a> 2019 &ndash; 2020 | <a href="https://github.com/sprajagopal">Github</a>
  
  </footer>
  </body>
</html>

