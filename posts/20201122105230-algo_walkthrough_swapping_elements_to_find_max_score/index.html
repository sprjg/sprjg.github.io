<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="article" />

<meta property="og:url" content="/posts/20201122105230-algo_walkthrough_swapping_elements_to_find_max_score/" />

<meta property="og:title" content="Algo walkthrough: swapping elements to find max score" />

<meta property="og:image" content="https://sprjg.github.io/ox-hugo/" />

<meta property="og:description" content="Problem statement Given an array of size \(n\), the beauty of this array is defined as sum of \(abs(index-value)\) for each element. Swapping two elements of this array, what is the maximum beauty possible?
Initial setup The initial setup consists of an unsorted array. Each element has a score defined as the absolute value of the difference the element&rsquo;s value and its index.
The absolute value The metric for each element gives us a sense of displacement." />

<meta name="twitter:card" content="summary_large_image">

<meta name="twitter:site" content="">

<meta name="twitter:creator" content="">

<meta name="twitter:title" content="Algo walkthrough: swapping elements to find max score" />

<meta name="twitter:description" content="Problem statement Given an array of size \(n\), the beauty of this array is defined as sum of \(abs(index-value)\) for each element. Swapping two elements of this array, what is the maximum beauty possible?
Initial setup The initial setup consists of an unsorted array. Each element has a score defined as the absolute value of the difference the element&rsquo;s value and its index.
The absolute value The metric for each element gives us a sense of displacement." />

<meta name="twitter:image" content="" />

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": ""
    },
    "articleSection" : "posts",
    "name" : "Algo walkthrough: swapping elements to find max score",
    "headline" : "Algo walkthrough: swapping elements to find max score",
    "description" : "Problem statement Given an array of size \\(n\\), the beauty of this array is defined as sum of \\(abs(index-value)\\) for each element. Swapping two elements of this array, what is the maximum beauty possible?\nInitial setup The initial setup consists of an unsorted array. Each element has a score defined as the absolute value of the difference the element\u0026rsquo;s value and its index.\nThe absolute value The metric for each element gives us a sense of displacement.",
    "inLanguage" : "en-US",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2020",
    "datePublished": "2020-11-23 00:00:00 \u002b0000 \u002b0000",
    "dateModified" : "2020-11-23 00:00:00 \u002b0000 \u002b0000",
    "url" : "\/posts\/20201122105230-algo_walkthrough_swapping_elements_to_find_max_score\/",
    "wordCount" : "3884",
    "keywords" : [ "arrays","intervals","Blog" ]
}
</script>


    <title>Algo walkthrough: swapping elements to find max score | Notes on engineering math</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
        <link href="https://fonts.googleapis.com/css2?family=Crimson+Text&display=swap" rel="stylesheet">

  </head>

  <body>
    <div class='site-title'> <div> Notes on engineering math </div> </div>
    <div id="posts-list">
    <nav>
    <ul class="menu">
      
      <li><a href="/posts/">Main</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/">About</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>
    </div>

<div class="article-meta">
<a href="/posts" style="text-decoration:none;color:black;"><h1><span class="title">Algo walkthrough: swapping elements to find max score</span></h1></a>
</div>

<main>
    <aside class="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#problem-statement">Problem statement</a></li>
    <li><a href="#initial-setup">Initial setup</a>
      <ul>
        <li><a href="#the-absolute-value">The absolute value</a></li>
        <li><a href="#displacement-from-what">Displacement from what?</a></li>
      </ul>
    </li>
    <li><a href="#a-new-of-approaching-this">A new of approaching this</a>
      <ul>
        <li><a href="#the-score">The score</a></li>
        <li><a href="#the-problem">The problem</a></li>
      </ul>
    </li>
    <li><a href="#model-1">Model 1</a>
      <ul>
        <li><a href="#i-1-e-1-i-2-e-2">\(i_1 &gt; e_1, i_2 &gt; e_2\)</a></li>
      </ul>
    </li>
    <li><a href="#model-2">Model 2</a>
      <ul>
        <li><a href="#a-larger-array-example-to-see-more-observations">A larger array example to see more observations</a></li>
        <li><a href="#strategy">Strategy</a></li>
      </ul>
    </li>
    <li><a href="#model-3">Model 3</a>
      <ul>
        <li><a href="#visualizing-intervals">Visualizing intervals</a></li>
        <li><a href="#transitivity">Transitivity</a></li>
        <li><a href="#achieving-transitivity">Achieving transitivity</a></li>
        <li><a href="#close-to-the-end">Close to the end</a></li>
      </ul>
    </li>
    <li><a href="#faster-way-to-find-these-elements">Faster way to find these elements</a>
      <ul>
        <li><a href="#edge-cases">Edge cases</a></li>
        <li><a href="#tests">Tests</a></li>
      </ul>
    </li>
    <li><a href="#an-even-faster-way">An even faster way?</a>
      <ul>
        <li><a href="#a-step-back">A step back</a></li>
        <li><a href="#tests">Tests</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
    
    <h2 id="problem-statement">Problem statement</h2>
<p>Given an array of size \(n\), the beauty of this array is defined as sum of \(abs(index-value)\) for each element.
Swapping two elements of this array, what is the maximum beauty possible?</p>
<h2 id="initial-setup">Initial setup</h2>
<p>The initial setup consists of an unsorted array. Each element has a score defined as the absolute value of the difference the element&rsquo;s value and its index.</p>
<h3 id="the-absolute-value">The absolute value</h3>
<p>The metric for each element gives us a sense of displacement. For example, if an element at index `4` is of value `10` the score for this is `6`. If the element was at index `5` and of value `11`, the score is still `6`.
This suggests that we are to think in terms of displacement.</p>
<h3 id="displacement-from-what">Displacement from what?</h3>
<p>Here we can think of the two parts in the difference. We have an index and we have a value. We could think of the element&rsquo;s score as its displacement. Currently the element is at index <code>i</code>. The displacement is <code>| i - e |</code>. So originally it was at <code>e</code>?</p>
<h2 id="a-new-of-approaching-this">A new of approaching this</h2>
<p>Imagine we have a row of bins. We are randomly  filling its slots with&hellip; the index of the slot. So we can choose to fill slot <code>2</code> with the value <code>2</code>. In fact we are allowed to fill the same slots multiple times (forget for now how this will be represented in an array as arrays only allow one value in a slot).
The bins are now filled. Suddenly, each of the elements start moving. They can move to the left or to the right. They can move at different speeds. After a while they all stop. Again, assume here that we now have a row of elements none overlapping by some miracle.
So initially we may have multiple elements in the same bin but now that they have randomly moved around they now occupy unique slots. Now we can represent them in an array.</p>
<h3 id="the-score">The score</h3>
<p>Now we can think of the score for each element as the amount it has moved from their original bins.</p>
<h3 id="the-problem">The problem</h3>
<p>The question for us is to swap the position of two elements in this array so that we increase the total score of the the whole array. This might have multiple possible solutions so instead we are looking for the pair of elements when swapped will increase the total score <span class="underline">the most</span>.</p>
<h4 id="details-of-the-question">Details of the question</h4>
<h5 id="increasing-the-score-of-one-element">Increasing the score of one element</h5>
<p>Is there a way to increase the score of just one element? The score for an element is <code>|i -e|</code>. The element&rsquo;s value <code>e</code> is fixed. The <code>i</code> can be changed but not in isolation. Because we are using an array, we are assuming that the indices are running contiguously. So every index must be occupied by some valid element and there cannot be any gaps. So we definitely need another element which can take this element&rsquo;s place</p>
<h5 id="swap">Swap</h5>
<p>This means swapping is the minimal, atomic way of changing the score of the array. During a swap, we change the indices of two elements in the array, so only the scores of these two elements change. By changing these, we are changing the total score.</p>
<h5 id="useful-swaps">Useful swaps</h5>
<p>Can we change any two elements to achieve a change in score? In other words, is there a way to reduce our search space?</p>
<h2 id="model-1">Model 1</h2>
<p>Say we represent an element as a tuple with its index and the value: <code>i, e</code>. Now let&rsquo;s take two elements \((i_1, e_1), (i_2, e_2)\). Their scores are \(| i_1 - e_1 |, | i_2 - e_2 |\).
Now let&rsquo;s define what swapping means. When we swap, we actually swap the indices of the elements leading to: \((i_2, e_1), (i_1, e_2)\). The scores now become: \(| i_2 - e_1 |, | i_1 - e_2 |\).
What is the increase in the score? \(| i_2 - e_1 | + | i_1 - e_2 | - | i_1 - e_1 | - | i_2 - e_2 |\)
At this point, we have to take different cases to analyze.</p>
<h3 id="i-1-e-1-i-2-e-2">\(i_1 &gt; e_1, i_2 &gt; e_2\)</h3>
<p>In this case the score is simply \(i_1 - e_1, i_2 - e_2\) before swapping and \(|i_2 - e_1|, |i_1 - e_2|\) after swapping. Here again there can be multiple cases:</p>
<h4 id="i-2-i-1-e-1-i-1-e-2">\(i_2 &gt; i_1 &gt; e_1, i_1 &gt; e_2\)</h4>
<p>In this case, the change in score becomes zero (remove the modulus and check for yourself).</p>
<h4 id="i-2-i-1-e-1-e-2-i-1">\(i_2 &gt; i_1 &gt; e_1, e_2 &gt; i_1\)</h4>
<p>In this case the change in score is: \(i_2 - e_1  +  e_2 - i_1  -  i_1 + e_1  -  i_2 + e_2 = e_2 - i_1 - i_1 + e_2 = 2(e_2 - i_1)\)</p>
<h2 id="model-2">Model 2</h2>
<p>As we see, it definitely helps to analyze elements as a tuple. We were able to rule out some parts of the search space.
But one issue is the number of different cases we could have. It might help to think of the elements as points in space. Let&rsquo;s try thinking of indices running along the <em>Y-axis</em> and plot the points as lengths running along <em>X-axis</em>. An example can help. Say the array: <code>[4, 5, 0, 1]</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> matplotlib
matplotlib<span style="color:#f92672">.</span>use(<span style="color:#e6db74">&#39;Agg&#39;</span>)
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt
<span style="color:#f92672">import</span> matplotlib.ticker <span style="color:#f92672">as</span> ticker
<span style="color:#f92672">import</span> random
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plot_array_as_2d</span>(array, filename):
    ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>gca()
    [plt<span style="color:#f92672">.</span>scatter(e, idx, s<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;s&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;k&#39;</span>) <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array)]
    plt<span style="color:#f92672">.</span>plot(list(range(<span style="color:#ae81ff">0</span>, len(array))), list(range(<span style="color:#ae81ff">0</span>, len(array))), <span style="color:#e6db74">&#39;b&#39;</span>)
    <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array):
        plt<span style="color:#f92672">.</span>plot(range(min(e, idx), max(e, idx) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), [idx] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> abs(idx <span style="color:#f92672">-</span> e )), <span style="color:#e6db74">&#39;k&#39;</span>)
    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ax<span style="color:#f92672">.</span>xaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_locator(ticker<span style="color:#f92672">.</span>MultipleLocator(base<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
    ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#39;Index&#39;</span>)
    ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#39;Value&#39;</span>)
    plt<span style="color:#f92672">.</span>savefig(filename)
    plt<span style="color:#f92672">.</span>close()

array <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>]
plot_array_as_2d(array, <span style="color:#e6db74">&#39;swaps-sample-small-array.png&#39;</span>)

length <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>
array <span style="color:#f92672">=</span> [random<span style="color:#f92672">.</span>choice(list(range(<span style="color:#ae81ff">0</span>, length))) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, length)]
plot_array_as_2d(array, <span style="color:#e6db74">&#39;swaps-sample-array-plot.png&#39;</span>)
</code></pre></div><figure>
    <img src="/ox-hugo/swaps-sample-small-array.png"/> 
</figure>

<p>The blue line is the <code>x=y</code> line i.e. <code>index=value</code> line.
Some immediate observations:</p>
<ul>
<li>Each element&rsquo;s score is the black line
<ul>
<li>Imagine moving the element to a different index while retaining the <em>Value</em> and try to see how the black line&rsquo;s length changes</li>
</ul>
</li>
<li>When elements are swapped, their <em>Value</em> remains the same but their score changes because the distance to the blue line changes</li>
<li>[Fallacy] Elements on left of the blue line seemingly have no benefit in moving <em>down</em> as this reduces the score.
<ul>
<li>But this is not true. It seems this way because of the example. See next example.</li>
</ul>
</li>
<li>[Fallacy] Elements on right of the blue line seemingly have no benefit in moving <em>up</em> as this reduces the score.
<ul>
<li>But this is not true. It seems this way because of the example. See next example.</li>
</ul>
</li>
<li>Two elements whose score lines (i.e. the black lines are overlapping) have no benefit swapping as this reduces their scores.</li>
</ul>
<p>It&rsquo;s time to expand our example to check our observations.</p>
<h3 id="a-larger-array-example-to-see-more-observations">A larger array example to see more observations</h3>
<p>We have seen certain observations in the previous visualization. Let&rsquo;s see how many of them still remain valid with a larger example:
<img src="/ox-hugo/swaps-sample-array-plot.png" alt=""></p>
<h4 id="overlapping-score-lines-before-and-after-swap">Overlapping score lines before and after swap</h4>
<p>This definitely seems to hold true.</p>
<ul>
<li>Notice the elements at index <code>6</code> and <code>8</code>. They are on the same side of the blue line. They have an overlapping score line. On swapping, whatever is gained by <code>6</code> is lost by <code>8</code>, leading to no change in the total score.</li>
<li>Notice the elements at index <code>18</code> and <code>17</code>. They are on opposite sides of the blue line. They have a small overlap. On swapping, this overlapping part is <em>lost</em> by both sides leading to decrease in scores for both, i.e. decrease in total score.</li>
<li>Notice the elements at index <code>5</code> and <code>7</code>. They are on the same right side of the blue line. They have an overlapping score line. On swapping, whatever is gained by <code>5</code> and <code>7</code>, leading to no change in the total score.</li>
</ul>
<h5 id="reverse-of-above-cases">Reverse of above cases</h5>
<p>For each of the cases above, notice that the reverse causes the opposite effect (for a zero change in score, the opposite is also zero change in score).
The second case is interesting. The decrease in score on removal of the overlap implies that causing an overlap increases score. We&rsquo;ll come back to this. <a id="orgc24782b"></a></p>
<h4 id="fallacy-no-benefit-in-crossing-the-blue-line">[Fallacy] No benefit in crossing the blue line</h4>
<p>This seems to be a fallacy in our previous observation. Notice how element at <code>15</code>, could in fact move down all the way, crossing the blue line, and achieve a better score (assuming we can have a partner who wants to move up).</p>
<h4 id="summary">Summary</h4>
<p>On swapping, one element moves up, one element moves down. We want an increase in score and we have seen <a href="#orgc24782b">that</a> causing an overlap increases score.
We also see that an element can cross the blue line to increase its own score.
Together with the above two observations, we can say that if we pick any two non-overlapping score lines and swap them, there is a definite increase in total score:</p>
<ul>
<li>Take <code>4</code> and <code>14</code>. On swapping, we get an increase in score which is equal to <code>2 x gap between the lines</code>.</li>
<li>Take <code>6</code> and <code>9</code>. On swapping, we get an increase in score which is equal to <code>2 x gap between the lines</code>.</li>
</ul>
<h3 id="strategy">Strategy</h3>
<p>We have reduced the search space to only non-overlapping elements. This is still a large search space of say \(s\) and our current understanding is to iterate over \(s^2\) options and find the maximum increase. Is there a way to reduce our search space further?</p>
<h2 id="model-3">Model 3</h2>
<p>From our observations in Model 2, we know that any two elements whose score lines don&rsquo;t overlap can be swapped to achieve an increase in total score. With this in mind, we can approach this problem with a fresh perspective.
Let&rsquo;s start by looking at each element as simply an interval. Think of a horizontal line with a start and an end.
Out of many such horizontal lines, we are looking for two that maximize spacing <em>between them</em>.</p>
<h3 id="visualizing-intervals">Visualizing intervals</h3>
<p>Let&rsquo;s try to see this in action.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> matplotlib
matplotlib<span style="color:#f92672">.</span>use(<span style="color:#e6db74">&#39;Agg&#39;</span>)
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt
<span style="color:#f92672">import</span> matplotlib.ticker <span style="color:#f92672">as</span> ticker
<span style="color:#f92672">import</span> random
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plot_array_as_2d_intervals</span>(array, filename):
    ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>gca()
    <span style="color:#75715e"># [plt.scatter(e, idx, s=100, marker=&#39;s&#39;, color=&#39;k&#39;) for idx, e in enumerate(array)]</span>
    <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array):
        plt<span style="color:#f92672">.</span>plot(range(min(e, idx), max(e, idx) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), [idx] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> abs(idx <span style="color:#f92672">-</span> e )), <span style="color:#e6db74">&#39;k&#39;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>)
        <span style="color:#66d9ef">if</span> e <span style="color:#f92672">==</span> idx:
            plt<span style="color:#f92672">.</span>scatter(e, e, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;s&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;k&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>)
    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ax<span style="color:#f92672">.</span>xaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_locator(ticker<span style="color:#f92672">.</span>MultipleLocator(base<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
    ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#39;Index&#39;</span>)
    ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#39;Value&#39;</span>)
    plt<span style="color:#f92672">.</span>grid()
    plt<span style="color:#f92672">.</span>savefig(filename)
    plt<span style="color:#f92672">.</span>close()

array <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>]
plot_array_as_2d_intervals(array, <span style="color:#e6db74">&#39;swaps-model3-sample-small-array.png&#39;</span>)

length <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>
array <span style="color:#f92672">=</span> [random<span style="color:#f92672">.</span>choice(list(range(<span style="color:#ae81ff">0</span>, length))) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, length)]
plot_array_as_2d_intervals(array, <span style="color:#e6db74">&#39;swaps-model3-sample-array-plot.png&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Python 3.8.5 (default, Sep  7 2020, 11:04:58)
[GCC 7.5.0] on linux
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; python.el: native completion setup loaded
</code></pre></div><figure>
    <img src="/ox-hugo/swaps-model3-sample-small-array.png"/> 
</figure>

<p><img src="/ox-hugo/swaps-model3-sample-array-plot.png" alt="">
Note that this is just <em>Model 2</em> without the blue line.
Our next step is to form a strategy to eliminate our search space fast.</p>
<h3 id="transitivity">Transitivity</h3>
<p>One way to eliminate parts of search space is by using a transitivity property. We need a way to show that two elements \(e_1, e_2\) cannot form the optimal swap, then we can eliminate a set of elements related to \(e_1\) and \(e_2\).
For example, <code>0</code> and <code>5</code> are already overlapped. So swapping them only leads to non-overlap and a reduction in score. Note that <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> are all elements that have a starting point that&rsquo;s before <code>5</code> <em>but after</em> <code>0</code>. So if <code>5</code> overlaps with <code>0</code>, then all these elements <code>1,2,3,4</code> also will overlap with <code>0</code>. We can eliminate them <em>for pairing with 0</em> without checking.
Another example. Note that <code>0</code> and <code>18</code> overlap but <code>0</code> and <code>17</code> do not. So this is not about the indices but rather the <em>starting point</em>. Here even though <code>18</code> has a higher index than <code>17</code>, the starting point <code>17</code> is after <code>18</code>. So we cannot eliminate <code>17</code> based on test of <code>0</code> and <code>18</code>. But we can eliminate pairing <code>0</code> with <code>7, 6, 5, 4, 3, 2</code>, as they all have starting points <em>before</em> <code>18</code>'s starting point.</p>
<h3 id="achieving-transitivity">Achieving transitivity</h3>
<p>Transitivity is useful but we need an apt data representation to exploit this. In our current representation, we just discussed how we are unable to eliminate <code>0,17</code> by testing for <code>0,18</code>. This is because the starting points are not related to the indices. This gives us a clue. Let&rsquo;s try sorting our intervals based on the starting point. Remember that we are not sorting the original array; that would defeat the purpose as we are only supposed to make one swap and sorting it is a lot more swaps. We are simply changing our visualization of the original array to look for any patterns.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> matplotlib
matplotlib<span style="color:#f92672">.</span>use(<span style="color:#e6db74">&#39;Agg&#39;</span>)
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt
<span style="color:#f92672">import</span> matplotlib.ticker <span style="color:#f92672">as</span> ticker
<span style="color:#f92672">import</span> random
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plot_array_as_2d_intervals</span>(array, filename):
    ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>gca()
    <span style="color:#75715e"># [plt.scatter(e, idx, s=100, marker=&#39;s&#39;, color=&#39;k&#39;) for idx, e in enumerate(array)]</span>
    pairs <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array):
        pairs<span style="color:#f92672">.</span>append([min(e, idx), max(e, idx)])
    sorted_start <span style="color:#f92672">=</span> sorted(pairs, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> e : e[<span style="color:#ae81ff">0</span>])
    <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(sorted_start):
        plt<span style="color:#f92672">.</span>plot(range(e[<span style="color:#ae81ff">0</span>], e[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), [idx] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> abs(e[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> e[<span style="color:#ae81ff">0</span>])), <span style="color:#e6db74">&#39;k&#39;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>)
        <span style="color:#66d9ef">if</span> e[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> e[<span style="color:#ae81ff">1</span>]:
            plt<span style="color:#f92672">.</span>scatter(idx, idx, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;s&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;k&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>)

    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ax<span style="color:#f92672">.</span>xaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_locator(ticker<span style="color:#f92672">.</span>MultipleLocator(base<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
    ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#39;Index&#39;</span>)
    ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#39;Value&#39;</span>)
    plt<span style="color:#f92672">.</span>grid()
    plt<span style="color:#f92672">.</span>savefig(filename)
    plt<span style="color:#f92672">.</span>close()

plot_array_as_2d_intervals(array, <span style="color:#e6db74">&#39;swaps-model3-sorted-sample-array-plot.png&#39;</span>)
</code></pre></div><figure>
    <img src="/ox-hugo/swaps-model3-sorted-sample-array-plot.png"/> 
</figure>

<p>We now have a way to tell which two elements are most apt for pairing. It seems the elements picked one each from the two extremes would give us a good spacing. But is it the best? May not be. We can see element at <code>1</code> (not element at <code>0</code>)would be a better choice to pair with <code>19</code>. We can see why: because <code>0</code> ends before <code>1</code> does and so has more spacing with <code>19</code>. Note that now have transitivity (almost). We can start with the extremes and say for sure that these may be our best bet.</p>
<h3 id="close-to-the-end">Close to the end</h3>
<p>Our observations from previous section show that a good starting point is crucial. We say <em>good</em> to mean <em>smallest</em>. In our representation we are pairing a small starting point element with a large starting point element. But our fallacy was coupling starting and ending points. Ending point value is completely independent from starting point value for each element.
So what is a desirable ending point value. We&rsquo;d like it to be as close to the starting point as possible. This makes the metric for ending point dependent on the element&rsquo;s starting point. In fact this is simply the score for each element. So for the first element of the swap, we are looking for an element that starts early and last a small score. For the other element of the swap, we only care that it starts as far as possible and not about the score because the gap doesn&rsquo;t depend on where the second element ends.
This gives us an idea. What if we also sort based on the end point?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> matplotlib
matplotlib<span style="color:#f92672">.</span>use(<span style="color:#e6db74">&#39;Agg&#39;</span>)
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt
<span style="color:#f92672">import</span> matplotlib.ticker <span style="color:#f92672">as</span> ticker
<span style="color:#f92672">import</span> random
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plot_array_as_2d_intervals</span>(array, filename):
    ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>gca()
    <span style="color:#75715e"># [plt.scatter(e, idx, s=100, marker=&#39;s&#39;, color=&#39;k&#39;) for idx, e in enumerate(array)]</span>
    pairs <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array):
        pairs<span style="color:#f92672">.</span>append([min(e, idx), max(e, idx)])
    sorted_start <span style="color:#f92672">=</span> sorted(pairs, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> e : e[<span style="color:#ae81ff">1</span>])
    <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(sorted_start):
        plt<span style="color:#f92672">.</span>plot(range(e[<span style="color:#ae81ff">0</span>], e[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), [idx] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> abs(e[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> e[<span style="color:#ae81ff">0</span>])), <span style="color:#e6db74">&#39;k&#39;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>)
        <span style="color:#66d9ef">if</span> e[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> e[<span style="color:#ae81ff">1</span>]:
            plt<span style="color:#f92672">.</span>scatter(idx, idx, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;s&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;k&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>)

    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ax<span style="color:#f92672">.</span>xaxis<span style="color:#f92672">.</span>set_major_formatter(ticker<span style="color:#f92672">.</span>FormatStrFormatter(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span>))
    ticker<span style="color:#f92672">.</span>MultipleLocator<span style="color:#f92672">.</span>MAXTICKS <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000</span>
    ax<span style="color:#f92672">.</span>yaxis<span style="color:#f92672">.</span>set_major_locator(ticker<span style="color:#f92672">.</span>MultipleLocator(base<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
    ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#39;Index&#39;</span>)
    ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#39;Value&#39;</span>)
    plt<span style="color:#f92672">.</span>grid()
    plt<span style="color:#f92672">.</span>savefig(filename)
    plt<span style="color:#f92672">.</span>close()

plot_array_as_2d_intervals(array, <span style="color:#e6db74">&#39;swaps-model3-sorted-end-sample-array-plot.png&#39;</span>)
</code></pre></div><figure>
    <img src="/ox-hugo/swaps-model3-sorted-end-sample-array-plot.png"/> 
</figure>

<p>For comparison, let&rsquo;s compare the two representations: sort based on start point, sort based on end point.</p>
<figure>
    <img src="/ox-hugo/swaps-model3-sorted-end-sample-array-plot.png"/> 
</figure>

<figure>
    <img src="/ox-hugo/swaps-model3-sorted-sample-array-plot.png"/> 
</figure>

<p>We are looking for two elements here:</p>
<ul>
<li>one that appears relatively close to the bottom in both these plots</li>
<li>one that appears relatively higher to the top in both these plots</li>
</ul>
<p>For each element we could sum up their index in both the arrays. We can then pick the element with the smallest sum and the element with the largest sum. This would give us the correct answer.
But is there a faster way to find these elements without having to sort the array twice?</p>
<h2 id="faster-way-to-find-these-elements">Faster way to find these elements</h2>
<p>Say, we allow for one sorting. Let&rsquo;s sort by start point:</p>
<p><img src="/ox-hugo/swaps-model3-sorted-sample-array-plot.png" alt="">
Let&rsquo;s try to find a suitable element to be the left side of the swap. We&rsquo;ll refer to the elements as a tuple of their start point, end point. Our first option is <code>(0, 15)</code>. So this element ends at <code>15</code>. Our best gap at this point starts at <code>15</code>. We can rule out any element that starts after <code>15</code> because they will only be worse i.e the gap would start later and not useful. So we have already removed part of our search space. All elements with start point greater than <code>15</code> can be ruled out.
Let&rsquo;s move on to the next option in our search: <code>(1,2)</code>. This gives a gap that starts at <code>2</code> which is obviously better our earlier option of <code>15</code>. And now we can rule out any element that has a start point greater than <code>2</code>. We have now removed a huge percentage of our search space now.
Our next option is <code>(1,3)</code> which means a gap that starts at <code>3</code>. But we already have a better option that starts at <code>2</code>.
Our options after this all start at <code>2</code> which we have already ruled out. We are done.
But this is just half the battle. We have only found the left side of the swap. We still need the right side of the swap.
For the right side element, our criteria is finding the largest start point i.e. the gap&rsquo;s end. But this is straightforward. We can simply take the last element of the current sorted array. We don&rsquo;t care about where this element ends because the gap size doesn&rsquo;t change.</p>
<h3 id="edge-cases">Edge cases</h3>
<p>Okay, so we have a full solution to find the left and the right side of the swap. What happens if we find that these two elements are overlapping? This means there are no elements that can be swapped to achieve a better score. Our criteria was maximizing the gap when we found these elements. But the best gap we can achieve is not positive.</p>
<h3 id="tests">Tests</h3>
<p>We&rsquo;ll write our strategy as code and check if it works against a random array. Just to be sure, we&rsquo;ll also compute the \(n^2\) solution ie. brute force by checking each element with every other element.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">array <span style="color:#f92672">=</span> [random<span style="color:#f92672">.</span>choice(list(range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000</span>))) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000</span>)]
pair_array <span style="color:#f92672">=</span> [[min(e, idx), max(e, idx)] <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array)]
sorted_start_array <span style="color:#f92672">=</span> sorted(pair_array, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> e: e[<span style="color:#ae81ff">0</span>])
best_start <span style="color:#f92672">=</span> sorted_start_array[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]
best_left <span style="color:#f92672">=</span> sorted_start_array
<span style="color:#66d9ef">for</span> e <span style="color:#f92672">in</span> sorted_start_array[<span style="color:#ae81ff">1</span>:]:
    <span style="color:#66d9ef">if</span> e[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> best_start:
        <span style="color:#66d9ef">if</span> e[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> best_start:
            best_start <span style="color:#f92672">=</span> e[<span style="color:#ae81ff">1</span>]
            best_left <span style="color:#f92672">=</span> e
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">break</span>

best_end <span style="color:#f92672">=</span> sorted_start_array[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]
best_right <span style="color:#f92672">=</span> sorted_start_array[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
score <span style="color:#f92672">=</span> sum([abs(e <span style="color:#f92672">-</span> idx) <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array)])
score <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (best_end <span style="color:#f92672">-</span> best_start)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Single pass solution:&#34;</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;   Maximum beauty achieved is </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (score))

<span style="color:#75715e"># CHECK 1</span>
<span style="color:#75715e"># array[51], array[984] = array[984], array[51]</span>
<span style="color:#75715e"># score = sum([abs(e - idx) for idx, e in enumerate(array)])</span>
<span style="color:#75715e"># print(score)</span>

<span style="color:#75715e"># CHECK 2</span>
<span style="color:#75715e"># n^2 test</span>
score <span style="color:#f92672">=</span> sum([abs(e <span style="color:#f92672">-</span> idx) <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array)])
max_improvement <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">for</span> i, a <span style="color:#f92672">in</span> enumerate(array):
    <span style="color:#66d9ef">for</span> j, b <span style="color:#f92672">in</span> enumerate(array):
        improvement <span style="color:#f92672">=</span> abs(j<span style="color:#f92672">-</span>a) <span style="color:#f92672">+</span> abs(i<span style="color:#f92672">-</span>b) <span style="color:#f92672">-</span> abs(i<span style="color:#f92672">-</span>a) <span style="color:#f92672">-</span> abs(j<span style="color:#f92672">-</span>b)
        <span style="color:#66d9ef">if</span> improvement <span style="color:#f92672">&gt;</span> max_improvement:
            max_improvement <span style="color:#f92672">=</span> improvement
            max_choice <span style="color:#f92672">=</span> [i, a, j, b]

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Polynomial solution:&#34;</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;   Maximum beauty achieved is </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (score <span style="color:#f92672">+</span> max_improvement))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Single pass solution:
   Maximum beauty achieved is 330735
Polynomial solution:
   Maximum beauty achieved is 330735
</code></pre></div><h2 id="an-even-faster-way">An even faster way?</h2>
<p>Our strategy currently:</p>
<ul>
<li>sort by start point</li>
<li>the element with highest start point is the right side of swap</li>
<li>among the elements with lower (not lowest) start points, find the one with the lowest end point</li>
</ul>
<p>Notice that the second step is direct confirmation that right side of the swap has to be the element with the highest start point. But how come we don&rsquo;t have a simple way to describe the left side of our swap?
Let&rsquo;s try that. In step 3, we are finding an element with the lowest end point. But this is among elements that already have low start points. But wait, if an element has the lowest end point, then it doesn&rsquo;t mean it has the lowest start point: imagine <code>(0, 10), (5, 6)</code> and compare them. So we have stumbled on a new finding. For the left side of the swap, we only care about the end point. This makes sense because we care about the gap&rsquo;s start which is defined by the element&rsquo;s end point, <em>regardless of where it starts</em>.
In our current strategy, sorting helps in two ways: (1) finding the right side of swap directly (2) while looking for the smallest end point, we are able to cut down search space because it&rsquo;s a sorted array (again, by exploiting transitivity).</p>
<h3 id="a-step-back">A step back</h3>
<p>Each element has two quantities: a start point and an end point. Our goal is to find two elements:</p>
<ul>
<li>One with the highest start point</li>
<li>One with the lowest end point <del>and also a low start point</del></li>
</ul>
<p>Notice that we no longer care about both quantities in each element. We either care about highest start point or about the lowest end point. This is crucial.
Imagine we had an array of dictionaries. Each dictionary has two quantities, <code>alpha</code> and <code>beta</code>. We are asked to find two elements: one with lowest <code>alpha</code> and one with highest <code>beta</code>. In this case, we could simply iterate over the array, improving our search as each new element is encountered.
We are exactly in that scenario. We can now avoid sorting and simply iterate over the array.</p>
<blockquote>
<p>This is because we updated our observation for the left side of the swap. We are no longer looking for an element that has both <em>good</em> start and <em>good</em> end. We are only looking <em>good</em> end.</p>
<p>For the right side of the swap, we were clear that we need to find the highest start point <em>regardless of its end point</em>. That should have given us a hint to explore the left side of the swap: we need the lowest end point <em>regardless of its start point</em>.</p>
</blockquote>
<h3 id="tests">Tests</h3>
<p>Let&rsquo;s remove the sorting. Instead we do a simple iteration, where we update our best start point and our best end point. The end of the iteration signals the end of our search (no transitivity as this is an unsorted array).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">array <span style="color:#f92672">=</span> [random<span style="color:#f92672">.</span>choice(list(range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000</span>))) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000</span>)]
pair_array <span style="color:#f92672">=</span> [[min(e, idx), max(e, idx)] <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array)]
best_start <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
best_left <span style="color:#f92672">=</span> pair_array[<span style="color:#ae81ff">0</span>]
best_end <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>
best_right <span style="color:#f92672">=</span> pair_array[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
<span style="color:#66d9ef">for</span> e <span style="color:#f92672">in</span> pair_array:
    <span style="color:#66d9ef">if</span> e[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> best_end:
        best_end <span style="color:#f92672">=</span> e[<span style="color:#ae81ff">1</span>]
        best_left <span style="color:#f92672">=</span> e
    <span style="color:#66d9ef">elif</span> e[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> best_start:
        best_start <span style="color:#f92672">=</span> e[<span style="color:#ae81ff">0</span>]
        best_right <span style="color:#f92672">=</span> e

score <span style="color:#f92672">=</span> sum([abs(e <span style="color:#f92672">-</span> idx) <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array)])
score <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (best_start <span style="color:#f92672">-</span> best_end)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Single pass solution:&#34;</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;   Maximum beauty achieved is </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (score))

<span style="color:#75715e"># CHECK 1</span>
<span style="color:#75715e"># array[51], array[984] = array[984], array[51]</span>
<span style="color:#75715e"># score = sum([abs(e - idx) for idx, e in enumerate(array)])</span>
<span style="color:#75715e"># print(score)</span>

<span style="color:#75715e"># CHECK 2</span>
<span style="color:#75715e"># n^2 test</span>
score <span style="color:#f92672">=</span> sum([abs(e <span style="color:#f92672">-</span> idx) <span style="color:#66d9ef">for</span> idx, e <span style="color:#f92672">in</span> enumerate(array)])
max_improvement <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">for</span> i, a <span style="color:#f92672">in</span> enumerate(array):
    <span style="color:#66d9ef">for</span> j, b <span style="color:#f92672">in</span> enumerate(array):
        improvement <span style="color:#f92672">=</span> abs(j<span style="color:#f92672">-</span>a) <span style="color:#f92672">+</span> abs(i<span style="color:#f92672">-</span>b) <span style="color:#f92672">-</span> abs(i<span style="color:#f92672">-</span>a) <span style="color:#f92672">-</span> abs(j<span style="color:#f92672">-</span>b)
        <span style="color:#66d9ef">if</span> improvement <span style="color:#f92672">&gt;</span> max_improvement:
            max_improvement <span style="color:#f92672">=</span> improvement
            max_choice <span style="color:#f92672">=</span> [i, a, j, b]

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Polynomial solution:&#34;</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;   Maximum beauty achieved is </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (score <span style="color:#f92672">+</span> max_improvement))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Single pass solution:
   Maximum beauty achieved is 320292
Polynomial solution:
   Maximum beauty achieved is 320292
</code></pre></div>
</main>

  <footer>
  <script src="/js/math-code.js"></script>
<script async src="/MathJax/es5/tex-chtml.js"></script>


<script async src="/js/center-img.js"></script>

  
  <hr/>
   <a href="https://sprjg.github.io">SPR</a> 2019 &ndash; 2020 | <a href="https://github.com/sprajagopal">Github</a>
  
  </footer>
  </body>
</html>

