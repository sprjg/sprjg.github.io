<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="article" />

<meta property="og:url" content="https://sprjg.github.io/posts/algo_walkthrough_jump_game/" />

<meta property="og:title" content="Algo walkthrough: jump game" />

<meta property="og:image" content="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_15-04-51_.png" />

<meta property="og:description" content="  Given an array of non-negative integers nums, you are initially positioned at the first index of the array.

  Each element in the array represents your maximum jump length at that position.

  Determine if you are able to reach the last index.
  " />

<meta name="twitter:card" content="summary_large_image">

<meta name="twitter:site" content="">

<meta name="twitter:creator" content="">

<meta name="twitter:title" content="Algo walkthrough: jump game" />

<meta name="twitter:description" content="  Given an array of non-negative integers nums, you are initially positioned at the first index of the array.

  Each element in the array represents your maximum jump length at that position.

  Determine if you are able to reach the last index.
  " />

<meta name="twitter:image" content="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_15-04-51_.png" />

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/sprjg.github.io"
    },
    "articleSection" : "posts",
    "name" : "Algo walkthrough: jump game",
    "headline" : "Algo walkthrough: jump game",
    "description" : "  Given an array of non-negative integers nums, you are initially positioned at the first index of the array.\n\n  Each element in the array represents your maximum jump length at that position.\n\n  Determine if you are able to reach the last index.\n  ",
    "inLanguage" : "en-US",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2021",
    "datePublished": "2021-02-26 00:00:00 \x2b0530 IST",
    "dateModified" : "2021-02-26 00:00:00 \x2b0530 IST",
    "url" : "https:\/\/sprjg.github.io\/posts\/algo_walkthrough_jump_game\/",
    "wordCount" : "2740",
    "keywords" : [ "graph-traversal","Blog" ]
}
</script>


    <title>Algo walkthrough: jump game | Notes on engineering math</title>
    <link rel="stylesheet" href="https://sprjg.github.io/css/style.css" />
    <link rel="stylesheet" href="https://sprjg.github.io/css/fonts.css" />
        <link href="https://fonts.googleapis.com/css2?family=Crimson+Text&display=swap" rel="stylesheet">

  </head>

  <body>
    <div class='site-title'> <div> Notes on engineering math </div> </div>
    <div id="posts-list">
    <nav>
    <ul class="menu">
      
      <li><a href="https://sprjg.github.io/posts/">Archive</a></li>
      
      <li><a href="https://sprjg.github.io/categories/">Categories</a></li>
      
      <li><a href="https://sprjg.github.io/tags/">Tags</a></li>
      
      <li><a href="https://sprjg.github.io/">About</a></li>
      
      <li><a href="https://sprjg.github.io/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>
    </div>

<div class="article-meta">
<a href="https://sprjg.github.io/posts" style="text-decoration:none;color:black;"><h1><span class="title">Algo walkthrough: jump game</span></h1></a>
</div>

<main>
  <aside class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#intuitions">Intuitions</a>
      <ul>
        <li><a href="#recursion">Recursion</a></li>
      </ul>
    </li>
    <li><a href="#a-graph-theory-approach">A graph theory approach</a>
      <ul>
        <li><a href="#why-time-exceeded">Why time exceeded?</a></li>
        <li><a href="#seemingly-promising-approaches-that-will-go-nowhere">Seemingly promising approaches that will go nowhere</a></li>
        <li><a href="#is-it-even-possible-to-avoid-a-quadratic-solution">Is it even possible to avoid a quadratic solution?</a></li>
      </ul>
    </li>
    <li><a href="#transitivity">Transitivity?</a>
      <ul>
        <li><a href="#using-the-node-indices">Using the node indices</a></li>
        <li><a href="#profiling">Profiling</a></li>
        <li><a href="#results">Results</a></li>
        <li><a href="#more-reductions">More reductions</a></li>
        <li><a href="#final-implementation">Final implementation</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>
    Given an array of non-negative integers nums, you are initially positioned at the first index of the array.

  Each element in the array represents your maximum jump length at that position.

  Determine if you are able to reach the last index.
  
  <blockquote>
<p><strong>Example 1:</strong></p>
<p>Input: nums = [2,3,1,1,4]</p>
<p>Output: true</p>
<p>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</p>
<p><strong>Example 2:</strong></p>
<p>Input: nums = [3,2,1,0,4]</p>
<p>Output: false</p>
<p>Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</p>
</blockquote>
<p><a href="https://leetcode.com/problems/jump-game/">Link to the problem</a></p>
<h2 id="intuitions">Intuitions</h2>
<p>There may be more than one path to reach the end of the array i.e. the <code>target</code> index. Say, we have 3 reachable spots from the current <code>0</code> index, we may go to any one of them <em>and then</em> ask the same question: can I reach the <code>target</code> from here?</p>
<h3 id="recursion">Recursion</h3>
<p>There&rsquo;s an inherent recursion at play here.</p>
<ul>
<li>We first ask: can I reach the <code>target</code> from index <code>0</code>?
<ul>
<li>
<p>Maybe we can: if the value at <code>array[0]</code> is more than or equal to the length of the array</p>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_15-04-51_.png"/> 
</figure>

</li>
<li>
<p>Or we cannot reach it in a single jump <em>but</em> we can make some progress towards the target:</p>
</li>
</ul>
</li>
</ul>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_15-06-19_.png"/> 
</figure>

<ul>
<li>Now we ask two more questions: can we reach the target from the cells tagged with the blue question?</li>
<li>Reachability from our current cell depends on the reachability from the two blue cells combined by an OR i.e. the answer for our current cell is <code>True</code> if the answer for <em>any of</em> the blue cells is <code>True</code>.</li>
</ul>
<h4 id="base-cases">Base cases</h4>
<h5 id="already-at-target">Already at target</h5>
<p>If our current index is equal to the target, nothing more needs to be checked. Our reachability question can be answered as <code>True</code>.</p>
<h5 id="no-blue-cells">No blue cells</h5>
<p>We have no blue cells to explore. So no more potential paths to the target exist <em>and</em> we are not at the target. So the answer to the reachability question is <code>False</code>.</p>
<h4 id="checking-bounds">Checking bounds</h4>
<p>We have to make sure not to go beyond the end of the array:</p>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_15-24-49_.png"/> 
</figure>

<h4 id="code">Code</h4>
<p>Let&rsquo;s try writing up this recursion algorithm:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> reduce

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test_reachability</span>(nums):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_reachable</span>(start_index, target):
        <span style="color:#66d9ef">if</span> start_index <span style="color:#f92672">==</span> target:
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">elif</span> start_index <span style="color:#f92672">+</span> nums[start_index] <span style="color:#f92672">&gt;=</span> target:
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">for</span> candidate <span style="color:#f92672">in</span> range(start_index <span style="color:#f92672">+</span> nums[start_index], start_index, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> is_reachable(candidate, target):
                    <span style="color:#66d9ef">return</span> True
            <span style="color:#66d9ef">return</span> False

    <span style="color:#66d9ef">return</span> is_reachable(<span style="color:#ae81ff">0</span>, len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">4</span>]))
<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span>]))
<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>]))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">False
True
True
</code></pre></div><ul>
<li>Note that the bound checking is done by <code>elif</code> condition</li>
<li>We are checking candidates from the right-most side and working backwards: <code>range(start_index + nums[start_index], start_index, -1)</code> i.e. we use a greedy approach in the order of solving the subproblems</li>
</ul>
<h4 id="correctness">Correctness</h4>
<p>This seems to work for the given examples. Let&rsquo;s run it against the full test set given in leetcode.</p>
<h5 id="time-exceeded">Time Exceeded</h5>
<p>The code fails with a <em>Time Exceeded</em> error. Let&rsquo;s explore how we can speed up this algorithm.</p>
<h6 id="memo-ization">Memo-ization</h6>
<p>This could be because we are solving the same subproblems again and again. Instead if we <em>memo-ized</em> the existing subproblems, we can exploit the overlapping nature of the subproblems. Also note that we add a subfunction <code>compute</code> inside <code>is_reachable</code>. This subfunction contains the non-trivial computations i.e. input is not memoized, input index is not the target index, input index can trivially reach the target (because the height of the input index is higher than the target index). We separate this for profiling reasons in the next section.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> reduce

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test_reachability</span>(nums):
    memo <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_reachable</span>(start_index, target):
        <span style="color:#66d9ef">if</span> start_index <span style="color:#f92672">==</span> target:
            memo[start_index] <span style="color:#f92672">=</span> True
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">elif</span> start_index <span style="color:#f92672">in</span> memo:
            <span style="color:#66d9ef">return</span> memo[start_index]

        <span style="color:#66d9ef">elif</span> start_index <span style="color:#f92672">+</span> nums[start_index] <span style="color:#f92672">&gt;=</span> target:
            memo[start_index] <span style="color:#f92672">=</span> True
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compute</span>():
                <span style="color:#66d9ef">for</span> candidate <span style="color:#f92672">in</span> range(start_index <span style="color:#f92672">+</span> nums[start_index], start_index, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                    <span style="color:#66d9ef">if</span> is_reachable(candidate, target):
                        memo[start_index] <span style="color:#f92672">=</span> True
                        <span style="color:#66d9ef">return</span> True
                memo[start_index] <span style="color:#f92672">=</span> False
                <span style="color:#66d9ef">return</span> False

            <span style="color:#66d9ef">return</span> compute()

    <span style="color:#66d9ef">return</span> is_reachable(<span style="color:#ae81ff">0</span>, len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">4</span>]))
<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span>]))
<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>]))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">False
True
True
</code></pre></div><!--list-separator-->
<ul>
<li>
<p>Profiling</p>
<p>Now let&rsquo;s profile this algorithm for an input that returns <code>False</code>. The stress test here: the algorithm is unable to return <code>False</code> until checking all the subproblems i.e. <code>n</code> subproblems for an array of size <code>n</code>. This gives us an idea of time taken for a single subproblem i.e. <span class="sidenote">
<label class="sidenote-label" for="fn1">a single call</label>

<span class="sidenote-content">the memo-ized calls take negligible time, and so we ignore them</span>
</span>
 of <code>is_reachable</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> cProfile
cProfile<span style="color:#f92672">.</span>run(<span style="color:#e6db74">&#39;test_reachability(list(range(2500, -1, -1)) + [1,0])&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">3128757 function calls (7 primitive calls) in 2.415 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    2.415    2.415 &lt;string&gt;:1(&lt;module&gt;)
   2501/1    1.397    0.001    2.415    2.415 python-khrkr7:18(compute)
        1    0.000    0.000    2.415    2.415 python-khrkr7:3(test_reachability)
3126251/1    1.017    0.000    2.415    2.415 python-khrkr7:5(is_reachable)
        1    0.000    0.000    2.415    2.415 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.len}
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
</code></pre></div><p>Note how the <code>compute</code> function is called exactly <code>n+1</code> times. This is in line with our count of the number of subproblems.
How could we speed up our <code>compute</code> function? Currently we check the potential paths starting from the rightmost blue cell i.e. a greedy order. Could we instead check them in a random order? But this would not solve the stress test input i.e. checking every subproblem before rejecting the input as <code>False</code>. Besides, randomizing will have its overhead also. So this is not useful.</p>
</li>
</ul>
<h6 id="non-recursive-solution">Non-recursive solution</h6>
<p>We could try an equivalent non-recursive implementation to check if recursion slows down the computation. To do this:</p>
<ul>
<li>We need a <code>deque</code> that has the list of potential blue cells to check
<ul>
<li>This explicit <code>deque</code> plays the role of the implicit stack in recursion</li>
</ul>
</li>
<li>We maintain a <code>checked_already</code> set that plays the role of memo-ization. We avoid &ldquo;visiting&rdquo; cells that we already have</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Non-recursive implementation</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test_reachability</span>(nums):
    checked_already <span style="color:#f92672">=</span> set()
    to_check <span style="color:#f92672">=</span> deque()
    to_check<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">0</span>)
    target <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">while</span> to_check:
        current_cell_index <span style="color:#f92672">=</span> to_check<span style="color:#f92672">.</span>pop()
        checked_already<span style="color:#f92672">.</span>add(current_cell_index)
        <span style="color:#66d9ef">for</span> jump <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, nums[current_cell_index] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
            new_cell <span style="color:#f92672">=</span> current_cell_index <span style="color:#f92672">+</span> jump
            <span style="color:#66d9ef">if</span> new_cell <span style="color:#f92672">in</span> checked_already:
                <span style="color:#66d9ef">continue</span>
            <span style="color:#66d9ef">elif</span> new_cell <span style="color:#f92672">&gt;=</span> target:
                <span style="color:#66d9ef">return</span> True
            <span style="color:#66d9ef">else</span>:
                to_check<span style="color:#f92672">.</span>append(new_cell)

    <span style="color:#66d9ef">return</span> False

<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">4</span>]))
<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span>]))
<span style="color:#66d9ef">print</span>(test_reachability([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>]))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">False
True
True
</code></pre></div> <!--list-separator-->
<ul>
<li>
<p>Stress test</p>
<p>This is a particular stressful example. The idea is to create an array where every cell except the last is reachable from a source cell. This means a total of \(\frac{n (n+1)}{2}\) jumps are possible. But the ultimate result is <code>False</code> i.e. the last cell cannot be reached from the start cell. This means all of the jumps must be checked and ultimately discarded!
The stress input is: <code>list(range(2500, -1, -1)) + [1,0]</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> cProfile
cProfile<span style="color:#f92672">.</span>run(<span style="color:#e6db74">&#39;test_reachability(list(range(2500, -1, -1)) + [1,0])&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">         7508 function calls in 0.179 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.179    0.179 &lt;string&gt;:1(&lt;module&gt;)
        1    0.178    0.178    0.179    0.179 python-OCm2Di:3(test_reachability)
        1    0.000    0.000    0.179    0.179 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.len}
     2501    0.000    0.000    0.000    0.000 {method &#39;add&#39; of &#39;set&#39; objects}
     2501    0.000    0.000    0.000    0.000 {method &#39;append&#39; of &#39;collections.deque&#39; objects}
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
     2501    0.000    0.000    0.000    0.000 {method &#39;pop&#39; of &#39;collections.deque&#39; objects}
</code></pre></div><p>For the same input, we use one-fourth the time. That&rsquo;s definitely an improvement. But not enough of an improvement. <a id="org1bc7898"></a> Because a ten times increase in the input size leads to ~100 times increase in time:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">cProfile<span style="color:#f92672">.</span>run(<span style="color:#e6db74">&#39;test_reachability(list(range(25000, -1, -1)) + [1,0])&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">         75008 function calls in 14.729 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.002    0.002   14.729   14.729 &lt;string&gt;:1(&lt;module&gt;)
        1   14.721   14.721   14.726   14.726 python-OCm2Di:3(test_reachability)
        1    0.000    0.000   14.729   14.729 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.len}
    25001    0.002    0.000    0.002    0.000 {method &#39;add&#39; of &#39;set&#39; objects}
    25001    0.002    0.000    0.002    0.000 {method &#39;append&#39; of &#39;collections.deque&#39; objects}
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
    25001    0.002    0.000    0.002    0.000 {method &#39;pop&#39; of &#39;collections.deque&#39; objects}
</code></pre></div><p>To understand the issue we need more granular profiling. Let&rsquo;s use <a href="https://pypi.org/project/line-profiler">line_profiler</a>.</p>
</li>
</ul>
 <!--list-separator-->
<ul>
<li>
<p>Line profiler</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kernprof -l -v leetcode_jump_game_line_profiler.py
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Wrote profile results to leetcode_jump_game_line_profiler.py.lprof
Timer unit: 1e-06 s

Total time: 3.31316 s
File: leetcode_jump_game_line_profiler.py
Function: test_reachability at line 3

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def test_reachability(nums):
     5         1          2.0      2.0      0.0      checked_already = set()
     6         1          1.0      1.0      0.0      to_check = deque()
     7         1          0.0      0.0      0.0      to_check.append(0)
     8         1          1.0      1.0      0.0      target = len(nums) - 1
     9      2502        670.0      0.3      0.0      while to_check:
    10      2501        825.0      0.3      0.0          current_cell_index = to_check.pop()
    11      2501        902.0      0.4      0.0          checked_already.add(current_cell_index)
    12   3128751     792809.0      0.3     23.9          for jump in range(1, nums[current_cell_index] + 1):
    13   3126250     873711.0      0.3     26.4              new_cell = current_cell_index + jump
    14   3126250     890454.0      0.3     26.9              if new_cell in checked_already:
    15   3123750     752193.0      0.2     22.7                  continue
    16      2500        750.0      0.3      0.0              elif new_cell &gt;= target:
    17                                                           return True
    18                                                       else:
    19      2500        845.0      0.3      0.0                  to_check.append(new_cell)
    20
    21         1          0.0      0.0      0.0      return False

</code></pre></div><p>The issue is clearly the nested loop (<code>for</code> inside <code>while</code>). Ideal scenario: initially, the <code>for</code> loop has significant work to do (lots of unvisited cells) but later the <code>for</code> loop simply skips over already visited cells. But the for loop still must run the course. In this example, this statement  <code>new_cell = current_cell_index + jump</code> is called close to 3 million times! As the input size increases, this part exponentially grows. <a id="org7a0f122"></a>
Can we cut down the <code>for</code> loop search space?</p>
</li>
</ul>
</li>
</ul>
<h2 id="a-graph-theory-approach">A graph theory approach</h2>
<h3 id="why-time-exceeded">Why time exceeded?</h3>
<p>The algorithm takes an extreme amount of time when there is no way to reach the target index. It ends up checking each path <em>to</em> the target. Currently we start from the <code>0</code> index and explore the paths to the target. We cannot stop until every path is exhausted! This can be a huge amount of time since there are many edges in this graph.</p>
<h3 id="seemingly-promising-approaches-that-will-go-nowhere">Seemingly promising approaches that will go nowhere</h3>
<ul>
<li>Instead what if we started from the target and check in reverse? We&rsquo;ll check which cells can reach the target index: the cells in green. Then we check which cells can reach these green cells: the red cells.</li>
</ul>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_21-44-45_.png"/> 
</figure>

<p>Note that this can also fail for certain inputs. This is not necessarily a clean algorithm.</p>
<ul>
<li>In this graph, starting from the target leads to a huge amount of time. Starting from source quickly shows that no cells can be reached from source and we can return <code>False</code> immediately.</li>
</ul>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_21-54-35_.png"/> 
</figure>

<ul>
<li>The exact opposite is true for the following graph. Starting from target would lead to a quick answer. Since no cells can lead <em>to</em> the target, we can return <code>False</code> immediately.</li>
</ul>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-02-26_21-54-45_.png"/> 
</figure>

<ul>
<li>What if we could do both of these approaches? So now instead of creating one tree (which takes an excessive amount of time) we have to create two? That doesn&rsquo;t sound promising.</li>
</ul>
<h3 id="is-it-even-possible-to-avoid-a-quadratic-solution">Is it even possible to avoid a quadratic solution?</h3>
<p>Given a graph where the source cannot reach the target, is it possible to avoid a quadratic solution?</p>
<ul>
<li>
<p>If we visit all edges, then we have \(O(V^2)\) edges to visit</p>
</li>
<li>
<p>Can we avoid visiting all edges? In this example, note that the black node cannot be visited but to ascertain that, we must exhaust all edges from all the nodes (notice that the dotted edge could be an unchecked edge that actually allows us to reach the black node)</p>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-03-12_21-50-58_.png"/> 
</figure>

<p>So the fact the <a href="#org7a0f122">for loop visits already visited nodes</a> is not an issue but a necessity (not a bug, a feature). We are actually checking all the edges from the current node in this for loop. And there&rsquo;s no way to avoid that.</p>
</li>
</ul>
<h2 id="transitivity">Transitivity?</h2>
<p>Could we discard some edges with a <em>partial</em> check? For example:</p>
<figure>
    <img src="https://sprjg.github.io/ox-hugo/screenshot2021-03-12_23-29-40_.png"/> 
</figure>

<p>In this case all the nodes that can be reached from <code>3</code> are already reachable from <code>1</code>. In other words, their reachable nodes are overlapping with <code>1</code> being a superset of <code>3</code>'s. So if we could detect that all the nodes reachable from <code>3</code> are already explored from <code>1</code>, then we can discard all the edges from <code>3</code>.</p>
<h3 id="using-the-node-indices">Using the node indices</h3>
<p>This is doable because the nodes are indexed. We just have to track the largest node currently reached or in queue. In this case, <code>1</code> edges are all explored and we note down that <code>6</code> is the largest node in queue.
Next we start at <code>2</code> and there are no edges so we move on.
Next we have <code>3</code>, but before exploring any edges, we check the largest node we can reach from <code>3</code>. This is easily doable since we know the largest jump achievable from <code>3</code>. In this case we don&rsquo;t reach beyond <code>6</code> i.e. the largest node already in queue. So there&rsquo;s no need to explore the edges of <code>3</code> and we simply move on to the next.</p>
<h3 id="profiling">Profiling</h3>
<p>Our stress test is no longer a stress test. It&rsquo;s easily completed in 14ms!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kernprof -l -v leetcode_jump_game_line_profiler_improvements.py
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">2500
Wrote profile results to leetcode_jump_game_line_profiler_improvements.py.lprof
Timer unit: 1e-06 s

Total time: 0.014504 s
File: leetcode_jump_game_line_profiler_improvements.py
Function: test_reachability at line 3

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def test_reachability(nums):
     5         1          4.0      4.0      0.0      checked_already = set()
     6         1          1.0      1.0      0.0      to_check = deque()
     7         1          2.0      2.0      0.0      to_check.append(0)
     8         1          0.0      0.0      0.0      largest_in_deque = 0
     9         1          1.0      1.0      0.0      target = len(nums) - 1
    10         1          0.0      0.0      0.0      skipped = 0
    11      2502        828.0      0.3      5.7      while to_check:
    12      2501       1025.0      0.4      7.1          current_cell_index = to_check.pop()
    13      2501        984.0      0.4      6.8          if current_cell_index == target:
    14                                                       return True
    15      2501       1049.0      0.4      7.2          checked_already.add(current_cell_index)
    16      2501        938.0      0.4      6.5          start = current_cell_index + 1
    17      2501       1089.0      0.4      7.5          end = start + nums[current_cell_index]
    18      2501       1030.0      0.4      7.1          if not end-1 &lt;= largest_in_deque:
    19      2501       1023.0      0.4      7.1              for new_cell in range(start, end):
    20      2500       1143.0      0.5      7.9                  if new_cell &lt; largest_in_deque:
    21                                                               pass
    22      2500       1093.0      0.4      7.5                  elif new_cell in checked_already:
    23                                                               pass
    24      2500       1095.0      0.4      7.5                  elif new_cell &gt;= target:
    25                                                               return True
    26                                                           else:
    27      2500       1233.0      0.5      8.5                      to_check.append(new_cell)
    28      2500       1045.0      0.4      7.2                      largest_in_deque = new_cell
    29                                                   else:
    30      2500        912.0      0.4      6.3              skipped += 1
    31
    32         1          9.0      9.0      0.1      print(skipped)
    33         1          0.0      0.0      0.0      return False

</code></pre></div><h3 id="results">Results</h3>
<p>Testing against leetcode&rsquo;s full test set gives us:</p>
<blockquote>
<p>Runtime: 88 ms, faster than 65.22% of Python3 online submissions for Jump Game.</p>
<p>Memory Usage: 18.8 MB, less than 5.82% of Python3 online submissions for Jump Game.</p>
</blockquote>
<p>This is pretty bad. Can we do better?</p>
<h3 id="more-reductions">More reductions</h3>
<p>Our earlier idea can be explored further. Say <code>3</code> has edges that reach beyond <code>6</code>. We should then explore <code>3</code>'s edges but can we skip some of them? Particularly the edges that lead to <code>6</code> or less than <code>6</code> can be skipped.
We just modify our <code>start</code> variable:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">start <span style="color:#f92672">=</span> max(start, largest_in_deque)
</code></pre></div><h4 id="no-set-needed">No set needed</h4>
<p>In fact we no longer need the set. Every cell we visit must be a new cell since we are already checking the start and end appropriately</p>
<h4 id="no-deque-needed">No deque needed</h4>
<p>While we are at it we can remove the deque too! This is slightly trickier and involves modifying the while condition.</p>
<ul>
<li>
<p>Our first observation is the sequential insertion into the deque. This means a simple counter would play the same role</p>
</li>
<li>
<p>Two, instead of inserting indices, we could simply increment the maximum reachable index by 1 (since we only insert sequential indices)</p>
</li>
<li>
<p>Together, the <code>while</code> loop condition simply becomes a counter check</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">     to_check <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
     max_reachable <span style="color:#f92672">=</span> to_check <span style="color:#f92672">+</span> nums[to_check]
     target <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

     <span style="color:#66d9ef">while</span> to_check <span style="color:#f92672">&lt;=</span> max_reachable:
         <span style="color:#75715e"># stuff</span>
         to_check <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</code></pre></div></li>
<li>
<p>Better still, we could avoid updating inside the <code>for</code> loop. Just update the chunk of values reachable after it</p>
</li>
</ul>
<!--listend-->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">max_reachable <span style="color:#f92672">=</span> max(max_reachable, end<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
   to_check <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><ul>
<li>
<p>Now why is the <code>for</code> loop needed? Earlier it was to check if any of the cells &ldquo;explore&rdquo; each edge. But we longer explore edges, so we can remove the <code>for</code> loop. We can simply check if the <code>end-1&gt;=target</code> i.e. is the target reachable from the current cell</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">if</span> end<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> target:
    <span style="color:#66d9ef">return</span> True
</code></pre></div></li>
<li>
<p>There&rsquo;s more: we no longer need the <code>largest_in_deque</code> variable. Instead we are setting the <code>while</code> loop&rsquo;s limit to the maximum of current limit and the current <code>end</code> value</p>
</li>
</ul>
<h3 id="final-implementation">Final implementation</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test_reachability</span>(nums):
     <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
         <span style="color:#66d9ef">return</span> True

     to_check <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
     max_reachable <span style="color:#f92672">=</span> to_check <span style="color:#f92672">+</span> nums[to_check]
     target <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

     <span style="color:#66d9ef">while</span> to_check <span style="color:#f92672">&lt;=</span> max_reachable:
         start <span style="color:#f92672">=</span> to_check <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
         end <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> nums[to_check]
         <span style="color:#66d9ef">if</span> end<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> target:
             <span style="color:#66d9ef">return</span> True
        max_reachable <span style="color:#f92672">=</span> max(max_reachable, end<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        to_check <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

     <span style="color:#66d9ef">return</span> False
</code></pre></div><p>This puts us at the top 94%:</p>
<blockquote>
<p>Runtime: 80 ms, faster than 94.02% of Python3 online submissions for Jump Game.</p>
<p>Memory Usage: 16.3 MB, less than 15.78% of Python3 online submissions for Jump Game.</p>
</blockquote>
<p>Note that leetcode can have \(\pm 10\) ms variations so there&rsquo;s no point optimizing beyond a point.</p>

</main>

<div class="related-content">


<h3>See Also</h3>
<ul>
    
    <li><a href="https://sprjg.github.io/posts/algo_walkthrough_pacific_atlantic_water_flow/">Algo walkthrough: pacific atlantic water flow</a></li>
    
    <li><a href="https://sprjg.github.io/posts/algo_walkthrough_course_schedule/">Algo walkthrough: course schedule</a></li>
    
    <li><a href="https://sprjg.github.io/posts/algo_walkthrough_number_of_islands/">Algo walkthrough: number of islands</a></li>
    
</ul>

</div>

<script src="https://utteranc.es/client.js"
        repo="sprjg/sprjg.github.io"
        issue-term="title"
        label="blog-comments"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


  <footer>
  <script src="https://sprjg.github.io/js/math-code.js"></script>
<script async src="https://sprjg.github.io/MathJax/es5/tex-chtml.js"></script>


<script async src="https://sprjg.github.io/js/center-img.js"></script>

  
  <hr/>
  © <a href="https://sprjg.github.io">SPR</a> 2019 &ndash; 2021 | <a href="https://github.com/sprajagopal">Github</a>
  
  </footer>
  </body>
</html>

