<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="article" />

<meta property="og:url" content="https://sprjg.github.io/posts/20201123210516-algo_walkthrough_longest_sequence_in_unsorted_array/" />

<meta property="og:title" content="Algo walkthrough: longest sequence in unsorted array" />

<meta property="og:image" content="https://sprjg.github.io/ox-hugo/" />

<meta property="og:description" content="We have an unsorted array. It may or may not have a sequence of numbers. We have to find the length of the longest sequence." />

<meta name="twitter:card" content="summary_large_image">

<meta name="twitter:site" content="">

<meta name="twitter:creator" content="">

<meta name="twitter:title" content="Algo walkthrough: longest sequence in unsorted array" />

<meta name="twitter:description" content="We have an unsorted array. It may or may not have a sequence of numbers. We have to find the length of the longest sequence." />

<meta name="twitter:image" content="https://sprjg.github.io/ox-hugo/" />

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/sprjg.github.io"
    },
    "articleSection" : "posts",
    "name" : "Algo walkthrough: longest sequence in unsorted array",
    "headline" : "Algo walkthrough: longest sequence in unsorted array",
    "description" : "We have an unsorted array. It may or may not have a sequence of numbers. We have to find the length of the longest sequence.",
    "inLanguage" : "en-US",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2020",
    "datePublished": "2020-11-25 00:00:00 \u002b0000 \u002b0000",
    "dateModified" : "2020-11-25 00:00:00 \u002b0000 \u002b0000",
    "url" : "https:\/\/sprjg.github.io\/posts\/20201123210516-algo_walkthrough_longest_sequence_in_unsorted_array\/",
    "wordCount" : "5489",
    "keywords" : [ "arrays","Blog" ]
}
</script>


    <title>Algo walkthrough: longest sequence in unsorted array | Notes on engineering math</title>
    <link rel="stylesheet" href="https://sprjg.github.io/css/style.css" />
    <link rel="stylesheet" href="https://sprjg.github.io/css/fonts.css" />
        <link href="https://fonts.googleapis.com/css2?family=Crimson+Text&display=swap" rel="stylesheet">

  </head>

  <body>
    <div class='site-title'> <div> Notes on engineering math </div> </div>
    <div id="posts-list">
    <nav>
    <ul class="menu">
      
      <li><a href="https://sprjg.github.io/posts/">Main</a></li>
      
      <li><a href="https://sprjg.github.io/categories/">Categories</a></li>
      
      <li><a href="https://sprjg.github.io/tags/">Tags</a></li>
      
      <li><a href="https://sprjg.github.io/">About</a></li>
      
      <li><a href="https://sprjg.github.io/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>
    </div>

<div class="article-meta">
<a href="https://sprjg.github.io/posts" style="text-decoration:none;color:black;"><h1><span class="title">Algo walkthrough: longest sequence in unsorted array</span></h1></a>
</div>

<main>
    <aside class="toc">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#hints">Hints</a></li>
      </ul>
    </li>
    <li><a href="#variations-to-the-setup">Variations to the setup</a>
      <ul>
        <li><a href="#sorted-sequence-within-noise">Sorted sequence within noise</a></li>
      </ul>
    </li>
    <li><a href="#observations-from-our-detour">Observations from our detour</a>
      <ul>
        <li><a href="#o1---lookup">\(O(1)\) lookup</a></li>
      </ul>
    </li>
    <li><a href="#intuitions">Intuitions</a>
      <ul>
        <li><a href="#our-first-approach">Our first approach</a></li>
        <li><a href="#a-different-data-structure">A different data structure?</a></li>
        <li><a href="#intervals">Intervals?</a></li>
        <li><a href="#nothing-but-dictionaries">Nothing but dictionaries</a></li>
      </ul>
    </li>
    <li><a href="#testing">Testing</a></li>
    <li><a href="#improvements">Improvements</a>
      <ul>
        <li><a href="#maintaining-the-maximum-length-in-the-same-iteration">Maintaining the maximum length in the same iteration</a></li>
      </ul>
    </li>
    <li><a href="#understanding-the-best-solution">Understanding the best solution</a>
      <ul>
        <li><a href="#handling-duplicates">Handling duplicates</a></li>
        <li><a href="#the-loop">The loop</a></li>
        <li><a href="#the-set">The set</a></li>
        <li><a href="#takeaways-and-observations">Takeaways and observations</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
    We have an unsorted array. It may or may not have a sequence of numbers. We have to find the length of the longest sequence.
    <p><a href="https://leetcode.com/problems/longest-consecutive-sequence/">Link to the problem</a>.</p>
<h3 id="hints">Hints</h3>
<ul>
<li>They hint at a \(O(n)\) solution. This can be useful at a later point.</li>
<li>They also say the length of the array can be between \(1, 10000\). This means we can a small array of size \(10\) and manually try out solutions. This would probably scale fine.</li>
<li>Each element can be huge! \(-10^9, 10^9\). Note that the value is higher than the length of the array. This will be useful.</li>
</ul>
<h2 id="variations-to-the-setup">Variations to the setup</h2>
<p>It can be useful to think of a series of events leading to this question. I think of this as starting from the solution. Say we have a sorted sequence of numbers.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>Let&rsquo;s add gaps between elements randomly.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td></td>
<td>7</td>
<td></td>
<td></td>
<td>8</td>
<td></td>
<td>9</td>
<td></td>
<td>10</td>
<td></td>
<td>11</td>
</tr>
</tbody>
</table>
<p>Now let&rsquo;s fill random elements to these gaps.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>76</td>
<td>87</td>
<td>2</td>
<td>8</td>
<td>3</td>
<td>21</td>
<td>67</td>
<td>15</td>
<td>4</td>
<td>9</td>
<td>5</td>
<td>50</td>
<td>43</td>
<td>99</td>
<td>6</td>
<td>14</td>
<td>7</td>
<td>29</td>
<td>78</td>
<td>8</td>
<td>41</td>
<td>9</td>
<td>70</td>
<td>10</td>
<td>54</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>Note that this is still not the original problem. Here our sequence is still sorted within &ldquo;the noise.&rdquo;
But just to understand the wrong approaches, let&rsquo;s try and solve this:</p>
<h3 id="sorted-sequence-within-noise">Sorted sequence within noise</h3>
<p>We know that the &ldquo;correct&rdquo; sequence will appear in its sorted order. The question hints at \(O(n)\) for its setup and what we have is arguably an easier problem. So let&rsquo;s aim to solve this in \(O(n)\).
When we say \(O(n)\) for an array, we intuitively think of a single pass. Let&rsquo;s explore this.
Some thoughts:</p>
<ul>
<li>We get a single pass</li>
<li>We see an element and we get to operate on it</li>
<li>Because we are thinking single pass, we also must have an answer at any point of time.
<ul>
<li>Say we have a \(100\) elements in the array. We have &ldquo;processed&rdquo; \(20\) of them. But wait &hellip; if our array was only of size \(20\), then we should have the final answer now. This means every time we process an element, we need a new answer (or stick to our previous answer), but we need some answer at that point</li>
</ul>
</li>
<li>Extra space. Based on the previous point, we should be thinking of storing our findings and our best guess at any time</li>
</ul>
<h4 id="the-single-pass">The single pass</h4>
<p>Now let&rsquo;s go over the array one element at a time and see what we can uncover.</p>
<ul>
<li>First element: \(1\)
<ul>
<li>we have no way to tell whether or not this is part of the sequence. But we definitely know that this can either be the start of the sequence or not part of it.</li>
<li>let&rsquo;s store this in a dictionary called <code>potential_start</code> with the key as <code>1</code>. But what can we store in the value part? Let&rsquo;s store the length of the potential sequence. <code>{1 : 1}</code></li>
</ul>
</li>
<li>Second element: \(76\)
<ul>
<li>we have more information than before. We know for sure this is not part of the potential sequence starting at \(1\) obviously. Because we expect the sequence to appear in order.</li>
<li>this previous point may push us towards searching for the next number of the existing sequence i.e. \(2\), but this can be wrong. Because we have no way to know whether the sequence starts at \(1\).</li>
<li>what if the sequence actually starts at \(76\)? No reason why it shouldn&rsquo;t. So this is also potentially a start of the sequence. Let&rsquo;s add this to our dictionary: \({1 : 1, 76 : 1}\)</li>
</ul>
</li>
<li>Third element: \(87\)
<ul>
<li>same reasoning as before. This could be the start of a new sequence: \(1 : 1, 76 : 1, 87 : 1\)</li>
</ul>
</li>
<li>Fourth element: \(2\)
<ul>
<li>now we have some hope. We can do constant time look up on dictionaries. So checking whether there is an element with key \(1\) (one less than our current element) is \(O(1)\). We do have an element with key \(1\)!</li>
<li>let&rsquo;s add \(2\) to the dictionary but make its value \(1 + 1 = 2\) . Because we already have an ancestor to it. \({1 : 1, 76 : 1, 2 : 2}\)</li>
<li>what if the array stops here? What if there are no more elements? Do we have an answer? No. We don&rsquo;t have the length of the longest sequence i.e. the largest number in the dictionary. So let&rsquo;s maintain that also. We can update this maximum value as and when new elements are added. Currently this maximum counter value is \(2\).</li>
</ul>
</li>
</ul>
<p>I hope the trend is obvious now. Because dictionary allows as \(O(1)\) lookup we are able to quickly check if an element&rsquo;s ancestor exists. If we continue this way, the maximum length sequence will be stored in our counter by the end of the pass.
Also the fact that the sequence appears in sorted order is the only reason we can hope to find the ancestor! But this is not true for the original problem. Let&rsquo;s go back to the original problem with these observations and hope that some of them will apply.</p>
<h2 id="observations-from-our-detour">Observations from our detour</h2>
<p>One thing that continues to be true is that \(O(n)\) implies that we must have an answer at every point of the pass. If the array abruptly stops, we must have an answer that&rsquo;s true for the subarray till then.
Another obvious but important observation is that we may have multiple potential sequences and we must &ldquo;track&rdquo; all of them.
One last observation is that we need a \(O(1)\) lookup. A way to check if our current element can be part of a sequence. In the detour we saw, this was easily accomplished by the dictionary because we knew for each potential sequence what the next element can be. But we do not have this luxury now. But let&rsquo;s explore this</p>
<h3 id="o1---lookup">\(O(1)\) lookup</h3>
<p>\(O(1)\) means that for every element we process, we are allowed to up to a constant number of checks, say 10, 20, 30, even but not anywhere close to \(n\) or even half of \(n\). Basically if we preset this number of checks to one constant value, that&rsquo;s still \(O(1)\).
But what could we check? We could check an element ahead, behind. We could check 20 elements ahead or behind. But this check has to yield <em>something</em>. This check has to tell us whether this current element can be part of a sequence.
Let&rsquo;s imagine some scenarios</p>
<h4 id="scenarios">Scenarios</h4>
<h5 id="ancestor-exists">Ancestor exists</h5>
<p>Say we put down an <code>x</code> for every element we encounter:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>mark</td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Now imagine, we do luckily encounter the next element in this potential sequence</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>mark</td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>This current element can check &ldquo;behind&rdquo; it and find it non-empty. This is huge! This means we can tell that there is <em>at least</em> two elements in the sequence.</p>
<h5 id="ancestor-arrives">Ancestor arrives</h5>
<p>This is the same thing but the ancestor arrives new, i.e. <code>3</code> is already here:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>mark</td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>then <code>2</code> arrives:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>mark</td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Now <code>2</code> could check &ldquo;ahead&rdquo; and find a nonempty value to confirm that there are <em>at least</em> two elements in the sequence.</p>
<h4 id="at-least-two-can-we-do-better">At least two: can we do better?</h4>
<p>Our \(O(1)\) lookup now tells us that there are <em>at least</em> two elements in the sequence. But can we somehow encode more information?
What if we store more than just a <code>x</code>? Say we also store the number of elements in the sequence at this point:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 arrives</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Now we know that there is <code>1</code> element in the sequence potentially. Now <code>2</code> arrives and sees that it has an element ahead which says it&rsquo;s part of a sequence of length 1. Now <code>2</code> checks behind and sees nothing. This means after <code>2</code> adds 1 to the sequence.</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 arrives</td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Now let&rsquo;s modify both <code>2, 3</code> to store 2 as our sequence has increased:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 arrives</td>
<td></td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>This means every time we add an element to a potential sequence we increment the value of everybody involved in the sequence. We could also store the maximum sequence value encountered in a separate variable. If and when a new sequence has a higher length, we update this maximum counter also. This gives us a ready answer at every iteration.
Let&rsquo;s check if this works always. Say this is the state</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td></td>
<td>2</td>
<td>2</td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Now <code>4</code> arrives:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td></td>
<td>2</td>
<td>2</td>
<td>x</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>It checks and behind, finding sequences in both directions. It&rsquo;s still possible to add the values ahead and behind, then increment it by 1 giving us <code>2 + 1 + 1 = 4</code> as the new sequence length. We update this for the entire sequence:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>We also modify our maximum counter (it was <code>2</code> before, now <code>4</code>). Our answer is readily available: <code>4</code>.</p>
<h5 id="time-complexity">Time complexity</h5>
<p>It seems our current approach works well. We have assumed nothing about sorted-ness, unique-ness etc. and it still seems to work.
But wait!
Every time a new element is added to the sequence, we are iterating over the sequence to modify the values. This takes \(O(s)\) time for a sequence of length \(s\) every time! This is not \(O(1)\) at all.</p>
<h4 id="o1---means-no-modification">\(O(1)\) means no modification</h4>
<p>Every new element encountered can do \(O(1)\) operation. But by definition our sequence may be growing so we cannot operate on the whole sequence. This means for a large part of our sequence, they&rsquo;ll contain values that we stored a long time back i.e. stale values. Stale values are obviously useless to update our findings.
So how (what) do we store? If we cannot rely on &ldquo;ahead&rdquo; or &ldquo;behind&rdquo; lookups, then we need something else to rely on.</p>
<h4 id="a-detour-to-our-detour">A detour to our detour</h4>
<p>Let&rsquo;s say <code>x</code>'s denote the elements we have &ldquo;seen&rdquo;:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>seen</td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>There are only a handful (constant) slots here that actually change the existing sequences&rsquo; length, marked by <code>o</code>:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>seen</td>
<td>o</td>
<td>x</td>
<td>x</td>
<td>o</td>
<td></td>
<td>o</td>
<td>x</td>
<td>o</td>
<td></td>
</tr>
</tbody>
</table>
<p>The good thing about these <code>o</code>'s is that they don&rsquo;t increase for an existing sequence. Say <code>4</code> arrives:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>seen</td>
<td>o</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>o</td>
<td>o</td>
<td>x</td>
<td>o</td>
<td></td>
</tr>
</tbody>
</table>
<p>The number of <code>o</code> slots remain the same, just changed after a new inclusion. Could we store these slots in a dictionary and check if a new element matches? If it does, we delete the element from the dictionary and add a new one (or maybe two).
At the start of the pass there are no <code>x</code> values and no <code>o</code> values. After the first <code>x</code>:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>seen</td>
<td></td>
<td>o</td>
<td>x</td>
<td>o</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>We have two <code>o</code> values in the dictionary. I imagine these <code>o</code> values as the shorelines of an island. The island may be huge but the shoreline is limited (let&rsquo;s not get into fractals!). When two such islands &ldquo;merge&rdquo;, the shoreline actually reduces. It goes from:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>seen</td>
<td></td>
<td>o</td>
<td>x</td>
<td>o</td>
<td>x</td>
<td>o</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>to:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 arrives</td>
<td></td>
<td>o</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>o</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>We have gone back to our dictionary lookup but with a few key modifications:</p>
<ul>
<li>we store the slots where activity is triggered. A new element arrives, sequence grows, or sequences merge. Earlier we simply stored the last element encountered in the sequence which is useless when the sequence can arrive out of order</li>
<li>the potential slots i.e. dictionary elements with <code>o</code> index key also contains the length(s) of their islands/sequences. This means tracking the length is done in constant time rather than updating the whole sequence with a new value. Just update the new <code>o</code> values being inserted
<ul>
<li>this needs some changes based on a single <code>o</code> shared by multiple islands but it can be done. Maybe an array is stored instead of integer?</li>
</ul>
</li>
</ul>
<h5 id="an-example">An example</h5>
<p>Let&rsquo;s try to &ldquo;manually solve&rdquo; an example with our new approach.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
array <span style="color:#f92672">=</span> [random<span style="color:#f92672">.</span>choice(list(range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">20</span>))) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>)]
<span style="color:#66d9ef">print</span>(array)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">[5, 10, 2, 0, 13, 14, 16, 0, 0, 13]
</code></pre></div><p>Say the given array is <code>[5, 10, 2, 0, 13, 14, 16, 0, 0, 13]</code>:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 arrives</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10 arrives</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2 arrives</td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0 arrives</td>
<td>x</td>
<td>1,1</td>
<td>x</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>13 arrives</td>
<td>x</td>
<td>1,1</td>
<td>x</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14 arrives</td>
<td>x</td>
<td>1,1</td>
<td>x</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>x</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>x</td>
<td>2</td>
<td></td>
</tr>
</tbody>
</table>
<p>Here we face a problem. How do we update the &ldquo;other&rdquo; side of the island? i.e. we need to update the element at <code>12</code> to 2. But how do we know what the other side is? We know that there are only two sides of an island. We could store for each shore (for each  <code>o</code>) to hold the address of the other shore. Note that we still only need to update one other shore i.e. a constant number of operations. Let&rsquo;s redo this example with an object in each shore.</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 arrives (max : 0)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10 arrives (max : 1)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2 arrives (max : 1)</td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:3}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0 arrives (max : 1)</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[1,1], &lsquo;o&rsquo;: [3,]}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>13 arrives (max : 1)</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[1,1], &lsquo;o&rsquo;: [3,]}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:14}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:12}</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14 arrives (max : 2)</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[1,1], &lsquo;o&rsquo;: [3,]}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td>{&lsquo;l&rsquo;:2, &lsquo;o&rsquo;:14}</td>
<td>x</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:2, &lsquo;o&rsquo;:12}</td>
<td></td>
</tr>
<tr>
<td>16 arrives (max : 2)</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[1,1], &lsquo;o&rsquo;: [3,]}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td>{&lsquo;l&rsquo;:2, &lsquo;o&rsquo;:14}</td>
<td>x</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[2, 1], &lsquo;o&rsquo;:12}</td>
<td>x</td>
</tr>
<tr>
<td>0 arrives (max : 2)</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[1,1], &lsquo;o&rsquo;: [3,]}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td>{&lsquo;l&rsquo;:2, &lsquo;o&rsquo;:14}</td>
<td>x</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[2, 1], &lsquo;o&rsquo;:12}</td>
<td>x</td>
</tr>
<tr>
<td>0 arrives (max : 2)</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[1,1], &lsquo;o&rsquo;: [3,]}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td>{&lsquo;l&rsquo;:2, &lsquo;o&rsquo;:14}</td>
<td>x</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[2, 1], &lsquo;o&rsquo;:12}</td>
<td>x</td>
</tr>
<tr>
<td>13 arrives (max : 2)</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[1,1], &lsquo;o&rsquo;: [3,]}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:1}</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:6}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:4}</td>
<td></td>
<td></td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:11}</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:1, &lsquo;o&rsquo;:9}</td>
<td>{&lsquo;l&rsquo;:2, &lsquo;o&rsquo;:14}</td>
<td>x</td>
<td>x</td>
<td>{&lsquo;l&rsquo;:[2, 1], &lsquo;o&rsquo;:12}</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>Our final max length is <code>2</code> as the max counter says.
But we just found another flaw in our approach. When we encounter an element that falls in the shore, we need to know which direction to propagate the shore. This can also be stored in the shore&rsquo;s object. Let&rsquo;s say we just <code>-1</code> for propagating behind and <code>1</code> for propagating ahead.</p>
<h5 id="a-simpler-way">A simpler way?</h5>
<p>Of course we could code this up and see how it works. We might even encounter more issues.
But one issue with our current approach is the number of different cases to handle:</p>
<ul>
<li>two shores merging</li>
<li>direction of the shore</li>
<li>a pointer to the other shore</li>
</ul>
<p>The implementation would look quite monstrous. But let&rsquo;s take the intuition we have gained and see if we can improve the approach.</p>
<h2 id="intuitions">Intuitions</h2>
<p>Our current understanding is that elements form islands. The islands merge when they come in contact. This creates bigger islands. Our task is to find the size of the biggest island.</p>
<h3 id="our-first-approach">Our first approach</h3>
<p>At first we tried storing the sequence length in every element of the sequence. Say the sequence length is visualized vertically. At first only <code>2</code> as arrived.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>x</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>index</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Then <code>3</code> arrives:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>x</th>
<th>x</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>value</td>
<td></td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>index</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Finally, <code>4</code> arrives:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>x</th>
<th>x</th>
<th>x</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>value</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>index</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Every time we modify the values, we are actually building a block that&rsquo;s one dimension higher. This is costly because we have create to go from <code>1x1</code> to <code>2x2</code> to <code>3x3</code> adding more and more blocks every time.
This type of visualization can help us understand why this operation was costly. We can also think of other ways to indicate the sequence size. At this point, we are just doodling.
Maybe we don&rsquo;t build a full block, just a pyramid?</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>x</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>value</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>index</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Again we need to know a &ldquo;symmetric&rdquo; way to build this. Which means we may have to know where the two ends of the sequence is all the time.</p>
<h3 id="a-different-data-structure">A different data structure?</h3>
<p>One issue that keeps coming up is keeping info on both sides of the sequence (where new elements could come). We tried to store only the end points in a dictionary. But we have lots of cases to handle when the sequence changes or grows or when merges happen. What if we don&rsquo;t keep the endpoints separate? Is there a way we could refer to the same sequence by either end point or start point?
We can assume this:</p>
<ul>
<li>there is only one sequence between a unique pair of start, end.</li>
<li>start is never equal to end</li>
<li>start, end are both integers</li>
</ul>
<p>But wait! Merge condition: when two sequences merge on the arrival of a new element. Then, a given key could find a sequence behind it and ahead of it. So mapping a key to one sequence is not possible. Only a pair of (start, end) are unique to a single sequence. So this wouldn&rsquo;t work.</p>
<h3 id="intervals">Intervals?</h3>
<p>What if we simply refer to each island by only its start and end points? Like an interval.</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>we would have:</p>
<table>
<thead>
<tr>
<th>start</th>
<th>end</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>The longest sequence is the one with the smallest start, \(a\), and the largest end, \(b\).
At this point this seems familiar: our problem consists of a set of intervals \((a,b)\). These intervals are changing as new elements appear. Intervals can grow, sometimes merge. We are constantly tracking the largest interval as our answer.
The crux of this is finding a (constant time) way to insert new element into its correct interval from a set of intervals. Is this even possible? Given a set of intervals, (even sorted) we still have to check at least a few of them to find the right place. Maybe binary search could do this in \((\log_{} n)\) but constant time? No way.
We could still go ahead and flesh out the details using this approach.</p>
<h4 id="not--on---but-okay">Not \(O(n)\) but okay</h4>
<ul>
<li>Say we maintain <del>an array</del> <em>a linked list</em> of intervals</li>
<li>We make sure that every new element is inserted using binary search to ensure sorted-ness of this array</li>
<li>Thankfully, there will be no overlaps of intervals because the intervals merge instead of staying overlapped; this should reduce some complexity</li>
</ul>
<p>Inserting in the middle will be \(O(\log n)\) if we use linked list instead of array. Every time we insert we also check if the recently modified interval can merge with the next (or previous) interval. If it can, we do merge in \(O(1)\) time.
Say we iterate through the final linked list of intervals to find the largest: \(O(n)\) time.
In total, this would be \(O(n \log_{} n + n)\).</p>
<h3 id="nothing-but-dictionaries">Nothing but dictionaries</h3>
<p>Out of all the approaches we have explored, dictionaries are the only data structures that gives us \(O(1)\) lookup. We may have to go back and clean up our dictionary approach, try coding it up, and see where that goes.
Our issue with the dictionary approach were the number of cases to handle in a single dictionary. Instead let&rsquo;s simplify this. We&rsquo;ll have two dictionaries: one with the start element as key, and one with the end element as key.</p>
<h4 id="start-element-dict-start">Start element dict: <code>start</code></h4>
<p>This will have only one value: the end point. So <code>start[e]</code> has the start point of a sequence that ends at <code>e</code>. If <code>start[e]</code> does not exist, then there are no sequences that <em>end</em> at <code>e</code>.</p>
<h4 id="end-element-dict-end">End element dict: <code>end</code></h4>
<p>This will have only one value: the start point. So <code>end[e]</code> has the end point of a sequence that starts at <code>e</code>. If <code>end[e]</code> does not exist, then there are no sequences that <em>start</em> at <code>e</code>.</p>
<h4 id="some-properties-to-maintain">Some properties to maintain</h4>
<ul>
<li><code>start[end[e]] = e</code>
The end point of a sequence that starts at <code>e</code> is <code>end[e]</code>. Then the start point of a sequence that ends at <code>end[e]</code> is <code>e</code>. Remember we have unique sequences only.</li>
<li><code>end[start[e]] = e</code>
The start point of a sequence that ends at <code>e</code> is <code>start[e]</code>. Then the end point of a sequence that starts at <code>start[e]</code> is <code>e</code>. Remember we have unique sequences only.</li>
</ul>
<h4 id="the-cases">The cases</h4>
<h5 id="an-element-e-arrives-e-1-is-an-end-point">An element <code>e</code> arrives; <code>e-1</code> is an end point</h5>
<p>This means we assign the value of <code>end[e-1]</code> to <code>end[e]</code>, and remove <code>end[e-1]</code>. But wait, there is some element in <code>start</code> that has a value of <code>e-1</code>. We have to change that to <code>e</code>, i.e. we need to change: <code>start[end[e-1]] = e</code>.</p>
<h5 id="an-element-e-arrives-e-plus-1-is-a-start-point">An element <code>e</code> arrives; <code>e+1</code> is a start point</h5>
<p>This means we assign the value of <code>start[e+1]</code> to <code>start[e]</code>, and remove <code>start[e+1]</code>. But wait, there is some element in <code>end</code> that has a value of <code>e+1</code>. We have to change that to <code>e</code>, i.e. we need to change: <code>end[start[e+1]] = e</code>.</p>
<h5 id="an-element-e-arrives-e-1-is-an-end-point-and-e-plus-1-is-a-start-point">An element <code>e</code> arrives;  <code>e-1</code> is an end point AND  <code>e+1</code> is a start point</h5>
<p>At the end of this we need we want a merged interval.</p>
<ul>
<li>Where does the sequence start when it ends at <code>e-1</code>?
It starts at <code>start[e-1]</code></li>
<li>Where does the sequence end when it starts at <code>e+1</code>?
It ends at <code>end[e+1]</code></li>
</ul>
<p>After our operations in this iteration, we want <code>end[start[e-1]] = end[e+1]</code> and <code>start[end[e+1]] = start[e-1]</code>. This is the crux of it. Reading it and drawing it out helps in understanding.
Before this iteration, we have:</p>
<table>
<thead>
<tr>
<th>start</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>e-1</td>
<td>a</td>
</tr>
</tbody>
</table>
<p>and</p>
<table>
<thead>
<tr>
<th>end</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>e+1</td>
<td>b</td>
</tr>
</tbody>
</table>
<p>After this iteration we need:</p>
<table>
<thead>
<tr>
<th>start</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>b = end[e+1]</td>
<td>a = start[e-1]</td>
</tr>
</tbody>
</table>
<p>and</p>
<table>
<thead>
<tr>
<th>end</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>a = start[e-1]</td>
<td>b = end[e+1]</td>
</tr>
</tbody>
</table>
<p>and we also</p>
<ul>
<li>delete <code>start[e-1]</code> (no sequence <em>ends</em> at <strong>e-1</strong>)</li>
<li>delete  <code>end[e+1]</code> (no sequence <em>starts</em> at <strong>e+1</strong>)</li>
</ul>
<h4 id="summary">Summary</h4>
<p>All of the above lookups and modifications are \(O(1)\). We have avoided nested dictionaries and arrays by simply using two dictionaries which makes the code cleaner and clear.
Note that we still have not tracked the largest sequence yet. For now, let&rsquo;s skip it and implement our current understanding. This is a quick implementation of this approach.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">array <span style="color:#f92672">=</span> [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>]
start <span style="color:#f92672">=</span> {}
end <span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">for</span> e <span style="color:#f92672">in</span> array:
    <span style="color:#66d9ef">if</span> e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> end <span style="color:#f92672">and</span> e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> start:
        start[end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        end[start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        end<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        start<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">elif</span> e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> end:
        end[e] <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        end<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">elif</span> e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> start:
        start[e] <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        start<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">else</span>:
        <span style="color:#75715e"># create start[e] = e, end[e] = e</span>
        start[e] <span style="color:#f92672">=</span> e
        end[e] <span style="color:#f92672">=</span> e

length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
seq_start <span style="color:#f92672">=</span> None
seq_end <span style="color:#f92672">=</span> None
<span style="color:#66d9ef">for</span> a,b <span style="color:#f92672">in</span> end<span style="color:#f92672">.</span>items():
    <span style="color:#66d9ef">if</span> b<span style="color:#f92672">-</span>a <span style="color:#f92672">&gt;</span> length:
        length <span style="color:#f92672">=</span> b<span style="color:#f92672">-</span>a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
        seq_start <span style="color:#f92672">=</span> a
        seq_end <span style="color:#f92672">=</span> b

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Best sequence of length </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> from </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> to </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (length, seq_start, seq_end))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Best sequence of length 4 from 3 to 6
</code></pre></div><p>This is wrong. The implementation does not work.
We missed a crucial factor: duplicate elements. When duplicate elements arrive, we may end up adding them again as a 1-length sequence but this violates the non-overlapping structure.
One way to correct this is to maintain a dictionary of processed elements and skip them when they arrive again.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">array <span style="color:#f92672">=</span> [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>]
start <span style="color:#f92672">=</span> {}
end <span style="color:#f92672">=</span> {}
processed <span style="color:#f92672">=</span> {}
<span style="color:#66d9ef">for</span> e <span style="color:#f92672">in</span> array:
    <span style="color:#66d9ef">if</span> e <span style="color:#f92672">in</span> processed:
        <span style="color:#66d9ef">continue</span>

    <span style="color:#66d9ef">if</span> e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> end <span style="color:#f92672">and</span> e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> start:
        start[end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        end[start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        end<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        start<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">elif</span> e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> end:
        end[e] <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        start[end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> e
        end<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">elif</span> e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> start:
        start[e] <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        end[start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> e
        start<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">else</span>:
        <span style="color:#75715e"># create start[e] = e, end[e] = e</span>
        start[e] <span style="color:#f92672">=</span> e
        end[e] <span style="color:#f92672">=</span> e
    processed[e] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
seq_start <span style="color:#f92672">=</span> None
seq_end <span style="color:#f92672">=</span> None
<span style="color:#66d9ef">for</span> a,b <span style="color:#f92672">in</span> end<span style="color:#f92672">.</span>items():
    <span style="color:#66d9ef">if</span> b<span style="color:#f92672">-</span>a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> length:
        length <span style="color:#f92672">=</span> b<span style="color:#f92672">-</span>a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
        seq_start <span style="color:#f92672">=</span> a
        seq_end <span style="color:#f92672">=</span> b

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Best sequence of length </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> from </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> to </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (length, seq_start, seq_end))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Best sequence of length 7 from 3 to 9
</code></pre></div><h2 id="testing">Testing</h2>
<p>Let&rsquo;s now try our implementation against the exhaustive test cases of <a href="https://leetcode.com/problems/longest-consecutive-sequence/description/">leetcode</a>. It seems to pass for the one test input given. Before we submit we could generate a lot of test cases randomly and paste it in the custom input to weed out any mistakes. Let&rsquo;s use the constraints given in leetcode:</p>
<blockquote>
<p>0 &lt;= nums.length &lt;= 10^4
-10^9 &lt;= nums[i] &lt;= 10^9</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">from</span> numpy <span style="color:#f92672">import</span> arange

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_array</span>():
    array <span style="color:#f92672">=</span> [int(random<span style="color:#f92672">.</span>random() <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">4</span>)]
    <span style="color:#66d9ef">return</span> array

<span style="color:#75715e"># let&#39;s generate 10 test cases</span>
tests <span style="color:#f92672">=</span> [generate_array() <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>)]
</code></pre></div><p>The array <code>tests</code> now contains an array of test cases. We&rsquo;ll write it out to a file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">print</span>(len(tests))
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;leetcode_longest_sequence_testcases.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> file:
    <span style="color:#66d9ef">for</span> test <span style="color:#f92672">in</span> tests:
        file<span style="color:#f92672">.</span>write(str(test))
        file<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">10
</code></pre></div><p>Unfortunately the test cases are not super useful because they all contain only 1-length sequences. This is to be expected from randomly generating arrays. We may have to start with a sequence then do a shuffle.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">from</span> numpy <span style="color:#f92672">import</span> arange

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_array</span>(array_length, element_min, element_max):
    rand <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> start, end: int(random<span style="color:#f92672">.</span>random() <span style="color:#f92672">*</span> (end <span style="color:#f92672">-</span> start) <span style="color:#f92672">+</span> start)
    seq_start_val <span style="color:#f92672">=</span> rand(element_min , element_max)
    seq_end_val <span style="color:#f92672">=</span> rand(seq_start_val, seq_start_val <span style="color:#f92672">+</span> array_length)
    seq_length <span style="color:#f92672">=</span> seq_end_val <span style="color:#f92672">-</span> seq_start_val
    array <span style="color:#f92672">=</span> [ rand(element_min , element_max) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, array_length)]
    start_idx <span style="color:#f92672">=</span> rand(<span style="color:#ae81ff">0</span>, array_length <span style="color:#f92672">-</span> seq_length)
    array[start_idx : start_idx <span style="color:#f92672">+</span> seq_length] <span style="color:#f92672">=</span> list(range(seq_start_val, seq_end_val))
    <span style="color:#66d9ef">return</span> array

<span style="color:#75715e"># let&#39;s generate 10 test cases</span>
tests <span style="color:#f92672">=</span> [generate_array(<span style="color:#ae81ff">10000</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>)]

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;leetcode_longest_sequence_testcases.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> file:
    <span style="color:#66d9ef">for</span> test <span style="color:#f92672">in</span> tests:
        file<span style="color:#f92672">.</span>write(str(test))
        file<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>This produces better test cases but we still have only one sequence in each array. There may multiple arrays too. Let&rsquo;s simulate that too. It&rsquo;s a minor modification. We simply overwrite the array with another sequence:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">from</span> numpy <span style="color:#f92672">import</span> arange

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_array</span>(array_length, element_min, element_max):
    rand <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> start, end: int(random<span style="color:#f92672">.</span>random() <span style="color:#f92672">*</span> (end <span style="color:#f92672">-</span> start) <span style="color:#f92672">+</span> start)
    array <span style="color:#f92672">=</span> [ rand(element_min , element_max) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, array_length)]
    num_sequences <span style="color:#f92672">=</span> rand(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>)
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, num_sequences):
        seq_start_val <span style="color:#f92672">=</span> rand(element_min , element_max)
        seq_end_val <span style="color:#f92672">=</span> rand(seq_start_val, seq_start_val <span style="color:#f92672">+</span> array_length)
        seq_length <span style="color:#f92672">=</span> seq_end_val <span style="color:#f92672">-</span> seq_start_val
        start_idx <span style="color:#f92672">=</span> rand(<span style="color:#ae81ff">0</span>, array_length <span style="color:#f92672">-</span> seq_length)
        array[start_idx : start_idx <span style="color:#f92672">+</span> seq_length] <span style="color:#f92672">=</span> list(range(seq_start_val, seq_end_val))
    <span style="color:#66d9ef">return</span> array

<span style="color:#75715e"># let&#39;s generate 10 test cases</span>
tests <span style="color:#f92672">=</span> [generate_array(<span style="color:#ae81ff">10000</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>)]

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;leetcode_longest_sequence_testcases.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> file:
    <span style="color:#66d9ef">for</span> test <span style="color:#f92672">in</span> tests:
        file<span style="color:#f92672">.</span>write(str(test))
        file<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>These tests also pass for our implementation. At this point, we can submit and see how we fare against the curated test sets for this problem to check for edge cases we haven&rsquo;t handled. Annnnd, we passed all the tests. The Though the implementation is not good clearly:</p>
<blockquote>
<p>Runtime: 60 ms, faster than 30.96% of Python3 online submissions for Longest Consecutive Sequence.
Memory Usage: 15.3 MB, less than 18.87% of Python3 online submissions for Longest Consecutive Sequence.</p>
</blockquote>
<p>We could definitely remove the loop at the end and instead maintain a largest sequence length.</p>
<h2 id="improvements">Improvements</h2>
<h3 id="maintaining-the-maximum-length-in-the-same-iteration">Maintaining the maximum length in the same iteration</h3>
<p>This is fairly simple. For each case, the length calculation changes:</p>
<ul>
<li>For the merge case: we calculate <code>end[e+1] - start[e-1] +1</code></li>
<li>For the append case: we calculate <code>e - start[e-1] + 1</code></li>
<li>For the prepend case: we calcualte <code>end[e+1] - e + 1</code></li>
<li>For the new sequence case: the length is <code>1</code></li>
</ul>
<p>If we do change the maximum length then we also change the start and end points (using which we calculate the length above).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">array <span style="color:#f92672">=</span> [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>]
start <span style="color:#f92672">=</span> {}
end <span style="color:#f92672">=</span> {}
processed <span style="color:#f92672">=</span> {}
max_length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
seq_start <span style="color:#f92672">=</span> None
seq_end <span style="color:#f92672">=</span> None
<span style="color:#66d9ef">for</span> e <span style="color:#f92672">in</span> array:
    <span style="color:#66d9ef">if</span> e <span style="color:#f92672">in</span> processed:
        <span style="color:#66d9ef">continue</span>

    <span style="color:#66d9ef">if</span> e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> end <span style="color:#f92672">and</span> e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> start:
        start[end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        end[start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">if</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> max_length:
            max_length <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            seq_start <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            seq_end <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        end<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        start<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">elif</span> e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> end:
        end[e] <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        start[end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> e
        <span style="color:#66d9ef">if</span> end[e] <span style="color:#f92672">-</span> e <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> max_length:
            max_length <span style="color:#f92672">=</span> end[e] <span style="color:#f92672">-</span> e <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        seq_start <span style="color:#f92672">=</span> e
        seq_end <span style="color:#f92672">=</span> end[e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        end<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">elif</span> e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> start:
        start[e] <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        end[start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> e
        <span style="color:#66d9ef">if</span> e <span style="color:#f92672">-</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> max_length:
            max_length <span style="color:#f92672">=</span> e <span style="color:#f92672">-</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            seq_start <span style="color:#f92672">=</span> start[e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            seq_end <span style="color:#f92672">=</span> e
        start<span style="color:#f92672">.</span>pop(e<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">else</span>:
        <span style="color:#75715e"># create start[e] = e, end[e] = e</span>
        start[e] <span style="color:#f92672">=</span> e
        end[e] <span style="color:#f92672">=</span> e
        <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> max_length:
            max_length <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            seq_start <span style="color:#f92672">=</span> e
            seq_end <span style="color:#f92672">=</span> e

    processed[e] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

<span style="color:#75715e"># length = 0</span>
<span style="color:#75715e"># seq_start = None</span>
<span style="color:#75715e"># seq_end = None</span>
<span style="color:#75715e"># for a,b in end.items():</span>
<span style="color:#75715e">#     if b-a+1 &gt; length:</span>
<span style="color:#75715e">#         length = b-a+1</span>
<span style="color:#75715e">#         seq_start = a</span>
<span style="color:#75715e">#         seq_end = b</span>

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Best sequence of length </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> from </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> to </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (max_length, seq_start, seq_end))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Best sequence of length 7 from 3 to 9
</code></pre></div><p>Let&rsquo;s see how we do:</p>
<blockquote>
<p>Runtime: 60 ms, faster than 30.96% of Python3 online submissions for Longest Consecutive Sequence.
Memory Usage: 15.4 MB, less than 16.52% of Python3 online submissions for Longest Consecutive Sequence.</p>
</blockquote>
<p>Not much difference.</p>
<h2 id="understanding-the-best-solution">Understanding the best solution</h2>
<p>At this point, let&rsquo;s check the best solution as per leetcode and see how we can connect our understanding to it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestConsecutive</span>(self, nums):
        longest_streak <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        num_set <span style="color:#f92672">=</span> set(nums)

        <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> num_set:
            <span style="color:#66d9ef">if</span> num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> num_set:
                current_num <span style="color:#f92672">=</span> num
                current_streak <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

                <span style="color:#66d9ef">while</span> current_num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> num_set:
                    current_num <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    current_streak <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

                longest_streak <span style="color:#f92672">=</span> max(longest_streak, current_streak)

        <span style="color:#66d9ef">return</span> longest_streak
</code></pre></div><h3 id="handling-duplicates">Handling duplicates</h3>
<p>Simply calling <code>set</code> on the array removes duplicates:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">        num_set <span style="color:#f92672">=</span> set(nums)
</code></pre></div><h3 id="the-loop">The loop</h3>
<p>Again the loop is over each element in the set. In our case, we go over array followed by an if block which is equivalent to this loop.</p>
<h3 id="the-set">The set</h3>
<p>The biggest difference is that there is only one set in this solution. They check if previous element i.e. <code>num - 1</code> is in the set. This is equivalent to us checking if <code>e-1</code> is present in <code>end</code>. If it is, they do no processing! This is the important difference from our solution. They simply continue on to the next element.</p>
<h4 id="checking-ahead-no-checking-behind">Checking ahead, no checking behind</h4>
<p>This is no checking &ldquo;behind&rdquo; in their implementation. They have fixed the counting direction as forwards only. So we only count when we encounter the start of a sequence. How do we know the start of a sequence? By checking if previous element is in the set.
This is extremely elegant because there is no additional storage involved. There is a single set which contains all the necessary elements to check. We simply go through them checking if we have encountered the start of a sequence.</p>
<h4 id="counting">Counting</h4>
<p>If we have encountered the start of a sequence, we start counting, i.e. keep incrementing counter as long as next element is also in the set. If by the end, we have a better length, we update our maximum length variable.</p>
<h3 id="takeaways-and-observations">Takeaways and observations</h3>
<ul>
<li>A loop inside a loop is not necessarily bad if it&rsquo;s only triggered very sparingly
<ul>
<li>That&rsquo;s why this solution is still \(O(n)\) even with the loop inside</li>
</ul>
</li>
<li>Using additional memory also means we are handling the additional overhead of &ldquo;seen&rdquo; and &ldquo;not seen&rdquo; elements
<ul>
<li>By using a single set and not having the overhead memory removes a lot of code that handles these cases</li>
</ul>
</li>
<li>Clever elimination
<ul>
<li>The use of a set allows for \(O(1)\) lookup of ancestors</li>
<li>We ignore anything that <em>is not</em> the start of a sequence</li>
</ul>
</li>
<li>Using a set
<ul>
<li>Forming a set from an array is arguably the biggest learning of all! I think the conversion itself would take \(O(n)\) time but this is okay. I definitely didn&rsquo;t think this pre-processing would make things faster. In fact I was <strong>dead-set on iterating the array</strong></li>
</ul>
</li>
</ul>

</main>

  <footer>
  <script src="https://sprjg.github.io/js/math-code.js"></script>
<script async src="https://sprjg.github.io/MathJax/es5/tex-chtml.js"></script>


<script async src="https://sprjg.github.io/js/center-img.js"></script>

  
  <hr/>
   <a href="https://sprjg.github.io">SPR</a> 2019 &ndash; 2020 | <a href="https://github.com/sprajagopal">Github</a>
  
  </footer>
  </body>
</html>

