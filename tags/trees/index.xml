<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>trees on Notes on engineering math</title>
    <link>https://sprjg.github.io/tags/trees/</link>
    <description>Recent content in trees on Notes on engineering math</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Jun 2021 00:00:00 +0530</lastBuildDate>
    
	<atom:link href="https://sprjg.github.io/tags/trees/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algo walkthrough: maximum path sum</title>
      <link>https://sprjg.github.io/posts/algo_walkthrough_maximum_path_sum/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0530</pubDate>
      
      <guid>https://sprjg.github.io/posts/algo_walkthrough_maximum_path_sum/</guid>
      <description>Link to the problem.
Intuitions Kadane&amp;rsquo;s algorithm is the closest known concept I can think of to this problem. The core idea of Kadane&amp;rsquo;s is this:
 [ITERATING method] it works for arrays because arrays are a sequence by definition [SWITCH condition] it is optimistic about a subsequence until it encounters a new element that completely destroys that optimism i.e. adding that new element to the existing subsequence leads to a value lower than the new element itself =&amp;gt; might as well start a new sequence starting from this new element [MEMORY] we always store the best sum encountered in a global variable [FRACTAL-ness] the best path is an array within this array  Kadane&amp;rsquo;s for a binary tree Our task is to find an equivalent binary tree idea for each point in the above list.</description>
    </item>
    
    <item>
      <title>Algo walkthrough: invert binary tree</title>
      <link>https://sprjg.github.io/posts/algo_walkthrough_invert_binary_tree/</link>
      <pubDate>Wed, 23 Jun 2021 00:00:00 +0530</pubDate>
      
      <guid>https://sprjg.github.io/posts/algo_walkthrough_invert_binary_tree/</guid>
      <description>This problem requires only the most basic understanding of the binary tree. We are simply asked to swap the left and right portions of the binary tree but at every node. The last part is particularly important. The challenge (if any) is not simply swapping left and right, but rather swapping the subtrees of the left and right parts also. Actually that&amp;rsquo;s pretty much the whole code in that sentence.</description>
    </item>
    
    <item>
      <title>Algo walkthrough: same tree</title>
      <link>https://sprjg.github.io/posts/algo_walkthrough_same_tree/</link>
      <pubDate>Wed, 23 Jun 2021 00:00:00 +0530</pubDate>
      
      <guid>https://sprjg.github.io/posts/algo_walkthrough_same_tree/</guid>
      <description>Link to the problem
Pessimism can be good   The central idea of this problem is to find differences between the trees.
 do the root values match? if they do, then check if the left subtrees match if they do, then check if the right subtrees match  Some base cases  as an axiom, if both trees are empty, then we consider them the same. So that becomes a base case to check explicitly also if only one of the trees are not empty, then we can simply reject the inputs as not equal  Code # Definition for a binary tree node.</description>
    </item>
    
  </channel>
</rss>